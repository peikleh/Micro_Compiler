Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    CONTINUE
    COMMENT
    BREAK

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM IDENTIFIER BEGIN pgm_body END
Rule 2     pgm_body -> decl func_declarations
Rule 3     decl -> string_decl decl
Rule 4     decl -> var_decl decl
Rule 5     decl -> empty
Rule 6     string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
Rule 7     var_decl -> var_type id_list SEMI
Rule 8     var_type -> FLOAT
Rule 9     var_type -> INT
Rule 10    any_type -> var_type
Rule 11    any_type -> VOID
Rule 12    id_list -> IDENTIFIER id_tail
Rule 13    id_tail -> COMM IDENTIFIER id_tail
Rule 14    id_tail -> empty
Rule 15    param_decl_list -> param_decl param_decl_tail
Rule 16    param_decl_list -> empty
Rule 17    param_decl -> var_type IDENTIFIER
Rule 18    param_decl_tail -> COMM param_decl param_decl_tail
Rule 19    param_decl_tail -> empty
Rule 20    func_declarations -> func_decl func_declarations
Rule 21    func_declarations -> empty
Rule 22    func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END
Rule 23    func_body -> decl stmt_list
Rule 24    stmt_list -> stmt stmt_list
Rule 25    stmt_list -> empty
Rule 26    stmt -> base_stmt
Rule 27    stmt -> if_stmt
Rule 28    stmt -> while_stmt
Rule 29    base_stmt -> assign_stmt
Rule 30    base_stmt -> read_stmt
Rule 31    base_stmt -> write_stmt
Rule 32    base_stmt -> return_stmt
Rule 33    assign_stmt -> assign_expr SEMI
Rule 34    assign_expr -> IDENTIFIER EQ_EQ expr
Rule 35    read_stmt -> READ L_PAR id_list R_PAR SEMI
Rule 36    write_stmt -> WRITE L_PAR id_list R_PAR SEMI
Rule 37    return_stmt -> RETURN expr SEMI
Rule 38    expr -> expr_prefix factor
Rule 39    expr_prefix -> expr_prefix factor addop
Rule 40    expr_prefix -> empty
Rule 41    factor -> factor_prefix postfix_expr
Rule 42    factor_prefix -> factor_prefix postfix_expr mulop
Rule 43    factor_prefix -> empty
Rule 44    postfix_expr -> primary
Rule 45    postfix_expr -> call_expr
Rule 46    call_expr -> IDENTIFIER L_PAR expr_list R_PAR
Rule 47    expr_list -> expr expr_list_tail
Rule 48    expr_list -> empty
Rule 49    expr_list_tail -> COMM expr expr_list_tail
Rule 50    expr_list_tail -> empty
Rule 51    primary -> L_PAR expr R_PAR
Rule 52    primary -> IDENTIFIER
Rule 53    primary -> INTLITERAL
Rule 54    primary -> FLOATLITERAL
Rule 55    addop -> PLUS
Rule 56    addop -> MINUS
Rule 57    mulop -> MULT
Rule 58    mulop -> DIV
Rule 59    if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
Rule 60    else_part -> ELSE decl stmt_list
Rule 61    else_part -> empty
Rule 62    cond -> expr compop expr
Rule 63    compop -> LESS
Rule 64    compop -> MORE
Rule 65    compop -> EQ
Rule 66    compop -> N_EQ
Rule 67    compop -> L_EQ
Rule 68    compop -> R_EQ
Rule 69    while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
Rule 70    empty -> <empty>

Terminals, with rules where they appear

BEGIN                : 1 22
BREAK                : 
COMM                 : 13 18 49
COMMENT              : 
CONTINUE             : 
DIV                  : 58
ELSE                 : 60
END                  : 1 22
ENDIF                : 59
ENDWHILE             : 69
EQ                   : 65
EQ_EQ                : 6 34
FLOAT                : 8
FLOATLITERAL         : 54
FUNCTION             : 22
IDENTIFIER           : 1 6 12 13 17 22 34 46 52
IF                   : 59
INT                  : 9
INTLITERAL           : 53
LESS                 : 63
L_EQ                 : 67
L_PAR                : 22 35 36 46 51 59 69
MINUS                : 56
MORE                 : 64
MULT                 : 57
N_EQ                 : 66
PLUS                 : 55
PROGRAM              : 1
READ                 : 35
RETURN               : 37
R_EQ                 : 68
R_PAR                : 22 35 36 46 51 59 69
SEMI                 : 6 7 33 35 36 37
STRING               : 6
STRINGLITERAL        : 6
VOID                 : 11
WHILE                : 69
WRITE                : 36
error                : 

Nonterminals, with rules where they appear

addop                : 39
any_type             : 22
assign_expr          : 33
assign_stmt          : 29
base_stmt            : 26
call_expr            : 45
compop               : 62
cond                 : 59 69
decl                 : 2 3 4 23 59 60 69
else_part            : 59
empty                : 5 14 16 19 21 25 40 43 48 50 61
expr                 : 34 37 47 49 51 62 62
expr_list            : 46
expr_list_tail       : 47 49
expr_prefix          : 38 39
factor               : 38 39
factor_prefix        : 41 42
func_body            : 22
func_decl            : 20
func_declarations    : 2 20
id_list              : 7 35 36
id_tail              : 12 13
if_stmt              : 27
mulop                : 42
param_decl           : 15 18
param_decl_list      : 22
param_decl_tail      : 15 18
pgm_body             : 1
postfix_expr         : 41 42
primary              : 44
program              : 0
read_stmt            : 30
return_stmt          : 32
stmt                 : 24
stmt_list            : 23 24 59 60 69
string_decl          : 3
var_decl             : 4
var_type             : 7 10 17
while_stmt           : 28
write_stmt           : 31

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM IDENTIFIER BEGIN pgm_body END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . IDENTIFIER BEGIN pgm_body END

    IDENTIFIER      shift and go to state 3


state 3

    (1) program -> PROGRAM IDENTIFIER . BEGIN pgm_body END

    BEGIN           shift and go to state 4


state 4

    (1) program -> PROGRAM IDENTIFIER BEGIN . pgm_body END
    (2) pgm_body -> . decl func_declarations
    (3) decl -> . string_decl decl
    (4) decl -> . var_decl decl
    (5) decl -> . empty
    (6) string_decl -> . STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
    (7) var_decl -> . var_type id_list SEMI
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    STRING          shift and go to state 9
    FUNCTION        reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    string_decl                    shift and go to state 5
    var_type                       shift and go to state 6
    pgm_body                       shift and go to state 10
    empty                          shift and go to state 11
    decl                           shift and go to state 12
    var_decl                       shift and go to state 8

state 5

    (3) decl -> string_decl . decl
    (3) decl -> . string_decl decl
    (4) decl -> . var_decl decl
    (5) decl -> . empty
    (6) string_decl -> . STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
    (7) var_decl -> . var_type id_list SEMI
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    STRING          shift and go to state 9
    FUNCTION        reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    WRITE           reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    ENDIF           reduce using rule 70 (empty -> .)
    ENDWHILE        reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    string_decl                    shift and go to state 5
    var_type                       shift and go to state 6
    empty                          shift and go to state 11
    decl                           shift and go to state 14
    var_decl                       shift and go to state 8

state 6

    (7) var_decl -> var_type . id_list SEMI
    (12) id_list -> . IDENTIFIER id_tail

    IDENTIFIER      shift and go to state 16

    id_list                        shift and go to state 15

state 7

    (9) var_type -> INT .

    IDENTIFIER      reduce using rule 9 (var_type -> INT .)


state 8

    (4) decl -> var_decl . decl
    (3) decl -> . string_decl decl
    (4) decl -> . var_decl decl
    (5) decl -> . empty
    (6) string_decl -> . STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
    (7) var_decl -> . var_type id_list SEMI
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    STRING          shift and go to state 9
    FUNCTION        reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    WRITE           reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    ENDIF           reduce using rule 70 (empty -> .)
    ENDWHILE        reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    string_decl                    shift and go to state 5
    var_type                       shift and go to state 6
    empty                          shift and go to state 11
    decl                           shift and go to state 17
    var_decl                       shift and go to state 8

state 9

    (6) string_decl -> STRING . IDENTIFIER EQ_EQ STRINGLITERAL SEMI

    IDENTIFIER      shift and go to state 18


state 10

    (1) program -> PROGRAM IDENTIFIER BEGIN pgm_body . END

    END             shift and go to state 19


state 11

    (5) decl -> empty .

    IF              reduce using rule 5 (decl -> empty .)
    WHILE           reduce using rule 5 (decl -> empty .)
    READ            reduce using rule 5 (decl -> empty .)
    WRITE           reduce using rule 5 (decl -> empty .)
    RETURN          reduce using rule 5 (decl -> empty .)
    IDENTIFIER      reduce using rule 5 (decl -> empty .)
    ELSE            reduce using rule 5 (decl -> empty .)
    ENDIF           reduce using rule 5 (decl -> empty .)
    FUNCTION        reduce using rule 5 (decl -> empty .)
    END             reduce using rule 5 (decl -> empty .)
    ENDWHILE        reduce using rule 5 (decl -> empty .)


state 12

    (2) pgm_body -> decl . func_declarations
    (20) func_declarations -> . func_decl func_declarations
    (21) func_declarations -> . empty
    (22) func_decl -> . FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END
    (70) empty -> .

    FUNCTION        shift and go to state 21
    END             reduce using rule 70 (empty -> .)

    func_decl                      shift and go to state 23
    empty                          shift and go to state 22
    func_declarations              shift and go to state 20

state 13

    (8) var_type -> FLOAT .

    IDENTIFIER      reduce using rule 8 (var_type -> FLOAT .)


state 14

    (3) decl -> string_decl decl .

    IF              reduce using rule 3 (decl -> string_decl decl .)
    WHILE           reduce using rule 3 (decl -> string_decl decl .)
    READ            reduce using rule 3 (decl -> string_decl decl .)
    WRITE           reduce using rule 3 (decl -> string_decl decl .)
    RETURN          reduce using rule 3 (decl -> string_decl decl .)
    IDENTIFIER      reduce using rule 3 (decl -> string_decl decl .)
    ELSE            reduce using rule 3 (decl -> string_decl decl .)
    ENDIF           reduce using rule 3 (decl -> string_decl decl .)
    FUNCTION        reduce using rule 3 (decl -> string_decl decl .)
    END             reduce using rule 3 (decl -> string_decl decl .)
    ENDWHILE        reduce using rule 3 (decl -> string_decl decl .)


state 15

    (7) var_decl -> var_type id_list . SEMI

    SEMI            shift and go to state 24


state 16

    (12) id_list -> IDENTIFIER . id_tail
    (13) id_tail -> . COMM IDENTIFIER id_tail
    (14) id_tail -> . empty
    (70) empty -> .

    COMM            shift and go to state 27
    SEMI            reduce using rule 70 (empty -> .)
    R_PAR           reduce using rule 70 (empty -> .)

    id_tail                        shift and go to state 25
    empty                          shift and go to state 26

state 17

    (4) decl -> var_decl decl .

    IF              reduce using rule 4 (decl -> var_decl decl .)
    WHILE           reduce using rule 4 (decl -> var_decl decl .)
    READ            reduce using rule 4 (decl -> var_decl decl .)
    WRITE           reduce using rule 4 (decl -> var_decl decl .)
    RETURN          reduce using rule 4 (decl -> var_decl decl .)
    IDENTIFIER      reduce using rule 4 (decl -> var_decl decl .)
    ELSE            reduce using rule 4 (decl -> var_decl decl .)
    ENDIF           reduce using rule 4 (decl -> var_decl decl .)
    FUNCTION        reduce using rule 4 (decl -> var_decl decl .)
    END             reduce using rule 4 (decl -> var_decl decl .)
    ENDWHILE        reduce using rule 4 (decl -> var_decl decl .)


state 18

    (6) string_decl -> STRING IDENTIFIER . EQ_EQ STRINGLITERAL SEMI

    EQ_EQ           shift and go to state 28


state 19

    (1) program -> PROGRAM IDENTIFIER BEGIN pgm_body END .

    $end            reduce using rule 1 (program -> PROGRAM IDENTIFIER BEGIN pgm_body END .)


state 20

    (2) pgm_body -> decl func_declarations .

    END             reduce using rule 2 (pgm_body -> decl func_declarations .)


state 21

    (22) func_decl -> FUNCTION . any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END
    (10) any_type -> . var_type
    (11) any_type -> . VOID
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    VOID            shift and go to state 30
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    var_type                       shift and go to state 31
    any_type                       shift and go to state 29

state 22

    (21) func_declarations -> empty .

    END             reduce using rule 21 (func_declarations -> empty .)


state 23

    (20) func_declarations -> func_decl . func_declarations
    (20) func_declarations -> . func_decl func_declarations
    (21) func_declarations -> . empty
    (22) func_decl -> . FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END
    (70) empty -> .

    FUNCTION        shift and go to state 21
    END             reduce using rule 70 (empty -> .)

    func_decl                      shift and go to state 23
    empty                          shift and go to state 22
    func_declarations              shift and go to state 32

state 24

    (7) var_decl -> var_type id_list SEMI .

    STRING          reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    FLOAT           reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    INT             reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    IF              reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    WHILE           reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    READ            reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    WRITE           reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    RETURN          reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    IDENTIFIER      reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    ELSE            reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    ENDIF           reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    FUNCTION        reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    END             reduce using rule 7 (var_decl -> var_type id_list SEMI .)
    ENDWHILE        reduce using rule 7 (var_decl -> var_type id_list SEMI .)


state 25

    (12) id_list -> IDENTIFIER id_tail .

    SEMI            reduce using rule 12 (id_list -> IDENTIFIER id_tail .)
    R_PAR           reduce using rule 12 (id_list -> IDENTIFIER id_tail .)


state 26

    (14) id_tail -> empty .

    SEMI            reduce using rule 14 (id_tail -> empty .)
    R_PAR           reduce using rule 14 (id_tail -> empty .)


state 27

    (13) id_tail -> COMM . IDENTIFIER id_tail

    IDENTIFIER      shift and go to state 33


state 28

    (6) string_decl -> STRING IDENTIFIER EQ_EQ . STRINGLITERAL SEMI

    STRINGLITERAL   shift and go to state 34


state 29

    (22) func_decl -> FUNCTION any_type . IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END

    IDENTIFIER      shift and go to state 35


state 30

    (11) any_type -> VOID .

    IDENTIFIER      reduce using rule 11 (any_type -> VOID .)


state 31

    (10) any_type -> var_type .

    IDENTIFIER      reduce using rule 10 (any_type -> var_type .)


state 32

    (20) func_declarations -> func_decl func_declarations .

    END             reduce using rule 20 (func_declarations -> func_decl func_declarations .)


state 33

    (13) id_tail -> COMM IDENTIFIER . id_tail
    (13) id_tail -> . COMM IDENTIFIER id_tail
    (14) id_tail -> . empty
    (70) empty -> .

    COMM            shift and go to state 27
    SEMI            reduce using rule 70 (empty -> .)
    R_PAR           reduce using rule 70 (empty -> .)

    id_tail                        shift and go to state 36
    empty                          shift and go to state 26

state 34

    (6) string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL . SEMI

    SEMI            shift and go to state 37


state 35

    (22) func_decl -> FUNCTION any_type IDENTIFIER . L_PAR param_decl_list R_PAR BEGIN func_body END

    L_PAR           shift and go to state 38


state 36

    (13) id_tail -> COMM IDENTIFIER id_tail .

    SEMI            reduce using rule 13 (id_tail -> COMM IDENTIFIER id_tail .)
    R_PAR           reduce using rule 13 (id_tail -> COMM IDENTIFIER id_tail .)


state 37

    (6) string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .

    STRING          reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    FLOAT           reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    INT             reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    IF              reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    WHILE           reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    READ            reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    WRITE           reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    RETURN          reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    IDENTIFIER      reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    ENDWHILE        reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    ELSE            reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    ENDIF           reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    FUNCTION        reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)
    END             reduce using rule 6 (string_decl -> STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI .)


state 38

    (22) func_decl -> FUNCTION any_type IDENTIFIER L_PAR . param_decl_list R_PAR BEGIN func_body END
    (15) param_decl_list -> . param_decl param_decl_tail
    (16) param_decl_list -> . empty
    (17) param_decl -> . var_type IDENTIFIER
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    R_PAR           reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    param_decl                     shift and go to state 39
    param_decl_list                shift and go to state 40
    empty                          shift and go to state 41
    var_type                       shift and go to state 42

state 39

    (15) param_decl_list -> param_decl . param_decl_tail
    (18) param_decl_tail -> . COMM param_decl param_decl_tail
    (19) param_decl_tail -> . empty
    (70) empty -> .

    COMM            shift and go to state 45
    R_PAR           reduce using rule 70 (empty -> .)

    param_decl_tail                shift and go to state 44
    empty                          shift and go to state 43

state 40

    (22) func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list . R_PAR BEGIN func_body END

    R_PAR           shift and go to state 46


state 41

    (16) param_decl_list -> empty .

    R_PAR           reduce using rule 16 (param_decl_list -> empty .)


state 42

    (17) param_decl -> var_type . IDENTIFIER

    IDENTIFIER      shift and go to state 47


state 43

    (19) param_decl_tail -> empty .

    R_PAR           reduce using rule 19 (param_decl_tail -> empty .)


state 44

    (15) param_decl_list -> param_decl param_decl_tail .

    R_PAR           reduce using rule 15 (param_decl_list -> param_decl param_decl_tail .)


state 45

    (18) param_decl_tail -> COMM . param_decl param_decl_tail
    (17) param_decl -> . var_type IDENTIFIER
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    param_decl                     shift and go to state 48
    var_type                       shift and go to state 42

state 46

    (22) func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR . BEGIN func_body END

    BEGIN           shift and go to state 49


state 47

    (17) param_decl -> var_type IDENTIFIER .

    COMM            reduce using rule 17 (param_decl -> var_type IDENTIFIER .)
    R_PAR           reduce using rule 17 (param_decl -> var_type IDENTIFIER .)


state 48

    (18) param_decl_tail -> COMM param_decl . param_decl_tail
    (18) param_decl_tail -> . COMM param_decl param_decl_tail
    (19) param_decl_tail -> . empty
    (70) empty -> .

    COMM            shift and go to state 45
    R_PAR           reduce using rule 70 (empty -> .)

    param_decl_tail                shift and go to state 50
    empty                          shift and go to state 43

state 49

    (22) func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN . func_body END
    (23) func_body -> . decl stmt_list
    (3) decl -> . string_decl decl
    (4) decl -> . var_decl decl
    (5) decl -> . empty
    (6) string_decl -> . STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
    (7) var_decl -> . var_type id_list SEMI
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    WRITE           reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    string_decl                    shift and go to state 5
    func_body                      shift and go to state 51
    empty                          shift and go to state 11
    var_type                       shift and go to state 6
    decl                           shift and go to state 52
    var_decl                       shift and go to state 8

state 50

    (18) param_decl_tail -> COMM param_decl param_decl_tail .

    R_PAR           reduce using rule 18 (param_decl_tail -> COMM param_decl param_decl_tail .)


state 51

    (22) func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body . END

    END             shift and go to state 53


state 52

    (23) func_body -> decl . stmt_list
    (24) stmt_list -> . stmt stmt_list
    (25) stmt_list -> . empty
    (26) stmt -> . base_stmt
    (27) stmt -> . if_stmt
    (28) stmt -> . while_stmt
    (70) empty -> .
    (29) base_stmt -> . assign_stmt
    (30) base_stmt -> . read_stmt
    (31) base_stmt -> . write_stmt
    (32) base_stmt -> . return_stmt
    (59) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (69) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (33) assign_stmt -> . assign_expr SEMI
    (35) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (36) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (37) return_stmt -> . RETURN expr SEMI
    (34) assign_expr -> . IDENTIFIER EQ_EQ expr

    END             reduce using rule 70 (empty -> .)
    IF              shift and go to state 62
    WHILE           shift and go to state 66
    READ            shift and go to state 56
    WRITE           shift and go to state 65
    RETURN          shift and go to state 55
    IDENTIFIER      shift and go to state 67

    base_stmt                      shift and go to state 63
    return_stmt                    shift and go to state 54
    while_stmt                     shift and go to state 64
    write_stmt                     shift and go to state 57
    assign_stmt                    shift and go to state 58
    assign_expr                    shift and go to state 59
    stmt                           shift and go to state 70
    empty                          shift and go to state 60
    stmt_list                      shift and go to state 61
    read_stmt                      shift and go to state 68
    if_stmt                        shift and go to state 69

state 53

    (22) func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END .

    FUNCTION        reduce using rule 22 (func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END .)
    END             reduce using rule 22 (func_decl -> FUNCTION any_type IDENTIFIER L_PAR param_decl_list R_PAR BEGIN func_body END .)


state 54

    (32) base_stmt -> return_stmt .

    IF              reduce using rule 32 (base_stmt -> return_stmt .)
    WHILE           reduce using rule 32 (base_stmt -> return_stmt .)
    READ            reduce using rule 32 (base_stmt -> return_stmt .)
    WRITE           reduce using rule 32 (base_stmt -> return_stmt .)
    RETURN          reduce using rule 32 (base_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 32 (base_stmt -> return_stmt .)
    ELSE            reduce using rule 32 (base_stmt -> return_stmt .)
    ENDIF           reduce using rule 32 (base_stmt -> return_stmt .)
    END             reduce using rule 32 (base_stmt -> return_stmt .)
    ENDWHILE        reduce using rule 32 (base_stmt -> return_stmt .)


state 55

    (37) return_stmt -> RETURN . expr SEMI
    (38) expr -> . expr_prefix factor
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    expr                           shift and go to state 72
    empty                          shift and go to state 71
    expr_prefix                    shift and go to state 73

state 56

    (35) read_stmt -> READ . L_PAR id_list R_PAR SEMI

    L_PAR           shift and go to state 74


state 57

    (31) base_stmt -> write_stmt .

    IF              reduce using rule 31 (base_stmt -> write_stmt .)
    WHILE           reduce using rule 31 (base_stmt -> write_stmt .)
    READ            reduce using rule 31 (base_stmt -> write_stmt .)
    WRITE           reduce using rule 31 (base_stmt -> write_stmt .)
    RETURN          reduce using rule 31 (base_stmt -> write_stmt .)
    IDENTIFIER      reduce using rule 31 (base_stmt -> write_stmt .)
    ELSE            reduce using rule 31 (base_stmt -> write_stmt .)
    ENDIF           reduce using rule 31 (base_stmt -> write_stmt .)
    END             reduce using rule 31 (base_stmt -> write_stmt .)
    ENDWHILE        reduce using rule 31 (base_stmt -> write_stmt .)


state 58

    (29) base_stmt -> assign_stmt .

    IF              reduce using rule 29 (base_stmt -> assign_stmt .)
    WHILE           reduce using rule 29 (base_stmt -> assign_stmt .)
    READ            reduce using rule 29 (base_stmt -> assign_stmt .)
    WRITE           reduce using rule 29 (base_stmt -> assign_stmt .)
    RETURN          reduce using rule 29 (base_stmt -> assign_stmt .)
    IDENTIFIER      reduce using rule 29 (base_stmt -> assign_stmt .)
    ELSE            reduce using rule 29 (base_stmt -> assign_stmt .)
    ENDIF           reduce using rule 29 (base_stmt -> assign_stmt .)
    END             reduce using rule 29 (base_stmt -> assign_stmt .)
    ENDWHILE        reduce using rule 29 (base_stmt -> assign_stmt .)


state 59

    (33) assign_stmt -> assign_expr . SEMI

    SEMI            shift and go to state 75


state 60

    (25) stmt_list -> empty .

    END             reduce using rule 25 (stmt_list -> empty .)
    ELSE            reduce using rule 25 (stmt_list -> empty .)
    ENDIF           reduce using rule 25 (stmt_list -> empty .)
    ENDWHILE        reduce using rule 25 (stmt_list -> empty .)


state 61

    (23) func_body -> decl stmt_list .

    END             reduce using rule 23 (func_body -> decl stmt_list .)


state 62

    (59) if_stmt -> IF . L_PAR cond R_PAR decl stmt_list else_part ENDIF

    L_PAR           shift and go to state 76


state 63

    (26) stmt -> base_stmt .

    IF              reduce using rule 26 (stmt -> base_stmt .)
    WHILE           reduce using rule 26 (stmt -> base_stmt .)
    READ            reduce using rule 26 (stmt -> base_stmt .)
    WRITE           reduce using rule 26 (stmt -> base_stmt .)
    RETURN          reduce using rule 26 (stmt -> base_stmt .)
    IDENTIFIER      reduce using rule 26 (stmt -> base_stmt .)
    END             reduce using rule 26 (stmt -> base_stmt .)
    ELSE            reduce using rule 26 (stmt -> base_stmt .)
    ENDIF           reduce using rule 26 (stmt -> base_stmt .)
    ENDWHILE        reduce using rule 26 (stmt -> base_stmt .)


state 64

    (28) stmt -> while_stmt .

    IF              reduce using rule 28 (stmt -> while_stmt .)
    WHILE           reduce using rule 28 (stmt -> while_stmt .)
    READ            reduce using rule 28 (stmt -> while_stmt .)
    WRITE           reduce using rule 28 (stmt -> while_stmt .)
    RETURN          reduce using rule 28 (stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 28 (stmt -> while_stmt .)
    END             reduce using rule 28 (stmt -> while_stmt .)
    ELSE            reduce using rule 28 (stmt -> while_stmt .)
    ENDIF           reduce using rule 28 (stmt -> while_stmt .)
    ENDWHILE        reduce using rule 28 (stmt -> while_stmt .)


state 65

    (36) write_stmt -> WRITE . L_PAR id_list R_PAR SEMI

    L_PAR           shift and go to state 77


state 66

    (69) while_stmt -> WHILE . L_PAR cond R_PAR decl stmt_list ENDWHILE

    L_PAR           shift and go to state 78


state 67

    (34) assign_expr -> IDENTIFIER . EQ_EQ expr

    EQ_EQ           shift and go to state 79


state 68

    (30) base_stmt -> read_stmt .

    IF              reduce using rule 30 (base_stmt -> read_stmt .)
    WHILE           reduce using rule 30 (base_stmt -> read_stmt .)
    READ            reduce using rule 30 (base_stmt -> read_stmt .)
    WRITE           reduce using rule 30 (base_stmt -> read_stmt .)
    RETURN          reduce using rule 30 (base_stmt -> read_stmt .)
    IDENTIFIER      reduce using rule 30 (base_stmt -> read_stmt .)
    ELSE            reduce using rule 30 (base_stmt -> read_stmt .)
    ENDIF           reduce using rule 30 (base_stmt -> read_stmt .)
    END             reduce using rule 30 (base_stmt -> read_stmt .)
    ENDWHILE        reduce using rule 30 (base_stmt -> read_stmt .)


state 69

    (27) stmt -> if_stmt .

    IF              reduce using rule 27 (stmt -> if_stmt .)
    WHILE           reduce using rule 27 (stmt -> if_stmt .)
    READ            reduce using rule 27 (stmt -> if_stmt .)
    WRITE           reduce using rule 27 (stmt -> if_stmt .)
    RETURN          reduce using rule 27 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 27 (stmt -> if_stmt .)
    END             reduce using rule 27 (stmt -> if_stmt .)
    ELSE            reduce using rule 27 (stmt -> if_stmt .)
    ENDIF           reduce using rule 27 (stmt -> if_stmt .)
    ENDWHILE        reduce using rule 27 (stmt -> if_stmt .)


state 70

    (24) stmt_list -> stmt . stmt_list
    (24) stmt_list -> . stmt stmt_list
    (25) stmt_list -> . empty
    (26) stmt -> . base_stmt
    (27) stmt -> . if_stmt
    (28) stmt -> . while_stmt
    (70) empty -> .
    (29) base_stmt -> . assign_stmt
    (30) base_stmt -> . read_stmt
    (31) base_stmt -> . write_stmt
    (32) base_stmt -> . return_stmt
    (59) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (69) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (33) assign_stmt -> . assign_expr SEMI
    (35) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (36) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (37) return_stmt -> . RETURN expr SEMI
    (34) assign_expr -> . IDENTIFIER EQ_EQ expr

    END             reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    ENDIF           reduce using rule 70 (empty -> .)
    ENDWHILE        reduce using rule 70 (empty -> .)
    IF              shift and go to state 62
    WHILE           shift and go to state 66
    READ            shift and go to state 56
    WRITE           shift and go to state 65
    RETURN          shift and go to state 55
    IDENTIFIER      shift and go to state 67

    base_stmt                      shift and go to state 63
    return_stmt                    shift and go to state 54
    while_stmt                     shift and go to state 64
    write_stmt                     shift and go to state 57
    assign_stmt                    shift and go to state 58
    assign_expr                    shift and go to state 59
    stmt                           shift and go to state 70
    empty                          shift and go to state 60
    stmt_list                      shift and go to state 80
    read_stmt                      shift and go to state 68
    if_stmt                        shift and go to state 69

state 71

    (40) expr_prefix -> empty .

    L_PAR           reduce using rule 40 (expr_prefix -> empty .)
    IDENTIFIER      reduce using rule 40 (expr_prefix -> empty .)
    INTLITERAL      reduce using rule 40 (expr_prefix -> empty .)
    FLOATLITERAL    reduce using rule 40 (expr_prefix -> empty .)


state 72

    (37) return_stmt -> RETURN expr . SEMI

    SEMI            shift and go to state 81


state 73

    (38) expr -> expr_prefix . factor
    (39) expr_prefix -> expr_prefix . factor addop
    (41) factor -> . factor_prefix postfix_expr
    (42) factor_prefix -> . factor_prefix postfix_expr mulop
    (43) factor_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    empty                          shift and go to state 82
    factor                         shift and go to state 83
    factor_prefix                  shift and go to state 84

state 74

    (35) read_stmt -> READ L_PAR . id_list R_PAR SEMI
    (12) id_list -> . IDENTIFIER id_tail

    IDENTIFIER      shift and go to state 16

    id_list                        shift and go to state 85

state 75

    (33) assign_stmt -> assign_expr SEMI .

    IF              reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    WHILE           reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    READ            reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    WRITE           reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    RETURN          reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    IDENTIFIER      reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    ELSE            reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    ENDIF           reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    ENDWHILE        reduce using rule 33 (assign_stmt -> assign_expr SEMI .)
    END             reduce using rule 33 (assign_stmt -> assign_expr SEMI .)


state 76

    (59) if_stmt -> IF L_PAR . cond R_PAR decl stmt_list else_part ENDIF
    (62) cond -> . expr compop expr
    (38) expr -> . expr_prefix factor
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    cond                           shift and go to state 86
    empty                          shift and go to state 71
    expr                           shift and go to state 87
    expr_prefix                    shift and go to state 73

state 77

    (36) write_stmt -> WRITE L_PAR . id_list R_PAR SEMI
    (12) id_list -> . IDENTIFIER id_tail

    IDENTIFIER      shift and go to state 16

    id_list                        shift and go to state 88

state 78

    (69) while_stmt -> WHILE L_PAR . cond R_PAR decl stmt_list ENDWHILE
    (62) cond -> . expr compop expr
    (38) expr -> . expr_prefix factor
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    cond                           shift and go to state 89
    empty                          shift and go to state 71
    expr                           shift and go to state 87
    expr_prefix                    shift and go to state 73

state 79

    (34) assign_expr -> IDENTIFIER EQ_EQ . expr
    (38) expr -> . expr_prefix factor
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    expr                           shift and go to state 90
    empty                          shift and go to state 71
    expr_prefix                    shift and go to state 73

state 80

    (24) stmt_list -> stmt stmt_list .

    END             reduce using rule 24 (stmt_list -> stmt stmt_list .)
    ELSE            reduce using rule 24 (stmt_list -> stmt stmt_list .)
    ENDIF           reduce using rule 24 (stmt_list -> stmt stmt_list .)
    ENDWHILE        reduce using rule 24 (stmt_list -> stmt stmt_list .)


state 81

    (37) return_stmt -> RETURN expr SEMI .

    IF              reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    WHILE           reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    READ            reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    WRITE           reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    RETURN          reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    IDENTIFIER      reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    END             reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    ELSE            reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    ENDIF           reduce using rule 37 (return_stmt -> RETURN expr SEMI .)
    ENDWHILE        reduce using rule 37 (return_stmt -> RETURN expr SEMI .)


state 82

    (43) factor_prefix -> empty .

    L_PAR           reduce using rule 43 (factor_prefix -> empty .)
    IDENTIFIER      reduce using rule 43 (factor_prefix -> empty .)
    INTLITERAL      reduce using rule 43 (factor_prefix -> empty .)
    FLOATLITERAL    reduce using rule 43 (factor_prefix -> empty .)


state 83

    (38) expr -> expr_prefix factor .
    (39) expr_prefix -> expr_prefix factor . addop
    (55) addop -> . PLUS
    (56) addop -> . MINUS

    R_PAR           reduce using rule 38 (expr -> expr_prefix factor .)
    LESS            reduce using rule 38 (expr -> expr_prefix factor .)
    MORE            reduce using rule 38 (expr -> expr_prefix factor .)
    EQ              reduce using rule 38 (expr -> expr_prefix factor .)
    N_EQ            reduce using rule 38 (expr -> expr_prefix factor .)
    L_EQ            reduce using rule 38 (expr -> expr_prefix factor .)
    R_EQ            reduce using rule 38 (expr -> expr_prefix factor .)
    SEMI            reduce using rule 38 (expr -> expr_prefix factor .)
    COMM            reduce using rule 38 (expr -> expr_prefix factor .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92

    addop                          shift and go to state 93

state 84

    (41) factor -> factor_prefix . postfix_expr
    (42) factor_prefix -> factor_prefix . postfix_expr mulop
    (44) postfix_expr -> . primary
    (45) postfix_expr -> . call_expr
    (51) primary -> . L_PAR expr R_PAR
    (52) primary -> . IDENTIFIER
    (53) primary -> . INTLITERAL
    (54) primary -> . FLOATLITERAL
    (46) call_expr -> . IDENTIFIER L_PAR expr_list R_PAR

    L_PAR           shift and go to state 99
    IDENTIFIER      shift and go to state 100
    INTLITERAL      shift and go to state 94
    FLOATLITERAL    shift and go to state 95

    call_expr                      shift and go to state 96
    postfix_expr                   shift and go to state 98
    primary                        shift and go to state 97

state 85

    (35) read_stmt -> READ L_PAR id_list . R_PAR SEMI

    R_PAR           shift and go to state 101


state 86

    (59) if_stmt -> IF L_PAR cond . R_PAR decl stmt_list else_part ENDIF

    R_PAR           shift and go to state 102


state 87

    (62) cond -> expr . compop expr
    (63) compop -> . LESS
    (64) compop -> . MORE
    (65) compop -> . EQ
    (66) compop -> . N_EQ
    (67) compop -> . L_EQ
    (68) compop -> . R_EQ

    LESS            shift and go to state 109
    MORE            shift and go to state 105
    EQ              shift and go to state 108
    N_EQ            shift and go to state 106
    L_EQ            shift and go to state 103
    R_EQ            shift and go to state 104

    compop                         shift and go to state 107

state 88

    (36) write_stmt -> WRITE L_PAR id_list . R_PAR SEMI

    R_PAR           shift and go to state 110


state 89

    (69) while_stmt -> WHILE L_PAR cond . R_PAR decl stmt_list ENDWHILE

    R_PAR           shift and go to state 111


state 90

    (34) assign_expr -> IDENTIFIER EQ_EQ expr .

    SEMI            reduce using rule 34 (assign_expr -> IDENTIFIER EQ_EQ expr .)


state 91

    (55) addop -> PLUS .

    L_PAR           reduce using rule 55 (addop -> PLUS .)
    IDENTIFIER      reduce using rule 55 (addop -> PLUS .)
    INTLITERAL      reduce using rule 55 (addop -> PLUS .)
    FLOATLITERAL    reduce using rule 55 (addop -> PLUS .)


state 92

    (56) addop -> MINUS .

    L_PAR           reduce using rule 56 (addop -> MINUS .)
    IDENTIFIER      reduce using rule 56 (addop -> MINUS .)
    INTLITERAL      reduce using rule 56 (addop -> MINUS .)
    FLOATLITERAL    reduce using rule 56 (addop -> MINUS .)


state 93

    (39) expr_prefix -> expr_prefix factor addop .

    L_PAR           reduce using rule 39 (expr_prefix -> expr_prefix factor addop .)
    IDENTIFIER      reduce using rule 39 (expr_prefix -> expr_prefix factor addop .)
    INTLITERAL      reduce using rule 39 (expr_prefix -> expr_prefix factor addop .)
    FLOATLITERAL    reduce using rule 39 (expr_prefix -> expr_prefix factor addop .)


state 94

    (53) primary -> INTLITERAL .

    MULT            reduce using rule 53 (primary -> INTLITERAL .)
    DIV             reduce using rule 53 (primary -> INTLITERAL .)
    PLUS            reduce using rule 53 (primary -> INTLITERAL .)
    MINUS           reduce using rule 53 (primary -> INTLITERAL .)
    SEMI            reduce using rule 53 (primary -> INTLITERAL .)
    LESS            reduce using rule 53 (primary -> INTLITERAL .)
    MORE            reduce using rule 53 (primary -> INTLITERAL .)
    EQ              reduce using rule 53 (primary -> INTLITERAL .)
    N_EQ            reduce using rule 53 (primary -> INTLITERAL .)
    L_EQ            reduce using rule 53 (primary -> INTLITERAL .)
    R_EQ            reduce using rule 53 (primary -> INTLITERAL .)
    R_PAR           reduce using rule 53 (primary -> INTLITERAL .)
    COMM            reduce using rule 53 (primary -> INTLITERAL .)


state 95

    (54) primary -> FLOATLITERAL .

    MULT            reduce using rule 54 (primary -> FLOATLITERAL .)
    DIV             reduce using rule 54 (primary -> FLOATLITERAL .)
    PLUS            reduce using rule 54 (primary -> FLOATLITERAL .)
    MINUS           reduce using rule 54 (primary -> FLOATLITERAL .)
    SEMI            reduce using rule 54 (primary -> FLOATLITERAL .)
    LESS            reduce using rule 54 (primary -> FLOATLITERAL .)
    MORE            reduce using rule 54 (primary -> FLOATLITERAL .)
    EQ              reduce using rule 54 (primary -> FLOATLITERAL .)
    N_EQ            reduce using rule 54 (primary -> FLOATLITERAL .)
    L_EQ            reduce using rule 54 (primary -> FLOATLITERAL .)
    R_EQ            reduce using rule 54 (primary -> FLOATLITERAL .)
    R_PAR           reduce using rule 54 (primary -> FLOATLITERAL .)
    COMM            reduce using rule 54 (primary -> FLOATLITERAL .)


state 96

    (45) postfix_expr -> call_expr .

    MULT            reduce using rule 45 (postfix_expr -> call_expr .)
    DIV             reduce using rule 45 (postfix_expr -> call_expr .)
    PLUS            reduce using rule 45 (postfix_expr -> call_expr .)
    MINUS           reduce using rule 45 (postfix_expr -> call_expr .)
    SEMI            reduce using rule 45 (postfix_expr -> call_expr .)
    LESS            reduce using rule 45 (postfix_expr -> call_expr .)
    MORE            reduce using rule 45 (postfix_expr -> call_expr .)
    EQ              reduce using rule 45 (postfix_expr -> call_expr .)
    N_EQ            reduce using rule 45 (postfix_expr -> call_expr .)
    L_EQ            reduce using rule 45 (postfix_expr -> call_expr .)
    R_EQ            reduce using rule 45 (postfix_expr -> call_expr .)
    R_PAR           reduce using rule 45 (postfix_expr -> call_expr .)
    COMM            reduce using rule 45 (postfix_expr -> call_expr .)


state 97

    (44) postfix_expr -> primary .

    MULT            reduce using rule 44 (postfix_expr -> primary .)
    DIV             reduce using rule 44 (postfix_expr -> primary .)
    PLUS            reduce using rule 44 (postfix_expr -> primary .)
    MINUS           reduce using rule 44 (postfix_expr -> primary .)
    SEMI            reduce using rule 44 (postfix_expr -> primary .)
    LESS            reduce using rule 44 (postfix_expr -> primary .)
    MORE            reduce using rule 44 (postfix_expr -> primary .)
    EQ              reduce using rule 44 (postfix_expr -> primary .)
    N_EQ            reduce using rule 44 (postfix_expr -> primary .)
    L_EQ            reduce using rule 44 (postfix_expr -> primary .)
    R_EQ            reduce using rule 44 (postfix_expr -> primary .)
    R_PAR           reduce using rule 44 (postfix_expr -> primary .)
    COMM            reduce using rule 44 (postfix_expr -> primary .)


state 98

    (41) factor -> factor_prefix postfix_expr .
    (42) factor_prefix -> factor_prefix postfix_expr . mulop
    (57) mulop -> . MULT
    (58) mulop -> . DIV

    PLUS            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    MINUS           reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    SEMI            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    LESS            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    MORE            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    EQ              reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    N_EQ            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    L_EQ            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    R_EQ            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    R_PAR           reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    COMM            reduce using rule 41 (factor -> factor_prefix postfix_expr .)
    MULT            shift and go to state 114
    DIV             shift and go to state 112

    mulop                          shift and go to state 113

state 99

    (51) primary -> L_PAR . expr R_PAR
    (38) expr -> . expr_prefix factor
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    expr                           shift and go to state 115
    empty                          shift and go to state 71
    expr_prefix                    shift and go to state 73

state 100

    (52) primary -> IDENTIFIER .
    (46) call_expr -> IDENTIFIER . L_PAR expr_list R_PAR

    MULT            reduce using rule 52 (primary -> IDENTIFIER .)
    DIV             reduce using rule 52 (primary -> IDENTIFIER .)
    PLUS            reduce using rule 52 (primary -> IDENTIFIER .)
    MINUS           reduce using rule 52 (primary -> IDENTIFIER .)
    SEMI            reduce using rule 52 (primary -> IDENTIFIER .)
    LESS            reduce using rule 52 (primary -> IDENTIFIER .)
    MORE            reduce using rule 52 (primary -> IDENTIFIER .)
    EQ              reduce using rule 52 (primary -> IDENTIFIER .)
    N_EQ            reduce using rule 52 (primary -> IDENTIFIER .)
    L_EQ            reduce using rule 52 (primary -> IDENTIFIER .)
    R_EQ            reduce using rule 52 (primary -> IDENTIFIER .)
    R_PAR           reduce using rule 52 (primary -> IDENTIFIER .)
    COMM            reduce using rule 52 (primary -> IDENTIFIER .)
    L_PAR           shift and go to state 116


state 101

    (35) read_stmt -> READ L_PAR id_list R_PAR . SEMI

    SEMI            shift and go to state 117


state 102

    (59) if_stmt -> IF L_PAR cond R_PAR . decl stmt_list else_part ENDIF
    (3) decl -> . string_decl decl
    (4) decl -> . var_decl decl
    (5) decl -> . empty
    (6) string_decl -> . STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
    (7) var_decl -> . var_type id_list SEMI
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    WRITE           reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    ENDIF           reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    string_decl                    shift and go to state 5
    var_type                       shift and go to state 6
    empty                          shift and go to state 11
    decl                           shift and go to state 118
    var_decl                       shift and go to state 8

state 103

    (67) compop -> L_EQ .

    L_PAR           reduce using rule 67 (compop -> L_EQ .)
    IDENTIFIER      reduce using rule 67 (compop -> L_EQ .)
    INTLITERAL      reduce using rule 67 (compop -> L_EQ .)
    FLOATLITERAL    reduce using rule 67 (compop -> L_EQ .)


state 104

    (68) compop -> R_EQ .

    L_PAR           reduce using rule 68 (compop -> R_EQ .)
    IDENTIFIER      reduce using rule 68 (compop -> R_EQ .)
    INTLITERAL      reduce using rule 68 (compop -> R_EQ .)
    FLOATLITERAL    reduce using rule 68 (compop -> R_EQ .)


state 105

    (64) compop -> MORE .

    L_PAR           reduce using rule 64 (compop -> MORE .)
    IDENTIFIER      reduce using rule 64 (compop -> MORE .)
    INTLITERAL      reduce using rule 64 (compop -> MORE .)
    FLOATLITERAL    reduce using rule 64 (compop -> MORE .)


state 106

    (66) compop -> N_EQ .

    L_PAR           reduce using rule 66 (compop -> N_EQ .)
    IDENTIFIER      reduce using rule 66 (compop -> N_EQ .)
    INTLITERAL      reduce using rule 66 (compop -> N_EQ .)
    FLOATLITERAL    reduce using rule 66 (compop -> N_EQ .)


state 107

    (62) cond -> expr compop . expr
    (38) expr -> . expr_prefix factor
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    expr                           shift and go to state 119
    empty                          shift and go to state 71
    expr_prefix                    shift and go to state 73

state 108

    (65) compop -> EQ .

    L_PAR           reduce using rule 65 (compop -> EQ .)
    IDENTIFIER      reduce using rule 65 (compop -> EQ .)
    INTLITERAL      reduce using rule 65 (compop -> EQ .)
    FLOATLITERAL    reduce using rule 65 (compop -> EQ .)


state 109

    (63) compop -> LESS .

    L_PAR           reduce using rule 63 (compop -> LESS .)
    IDENTIFIER      reduce using rule 63 (compop -> LESS .)
    INTLITERAL      reduce using rule 63 (compop -> LESS .)
    FLOATLITERAL    reduce using rule 63 (compop -> LESS .)


state 110

    (36) write_stmt -> WRITE L_PAR id_list R_PAR . SEMI

    SEMI            shift and go to state 120


state 111

    (69) while_stmt -> WHILE L_PAR cond R_PAR . decl stmt_list ENDWHILE
    (3) decl -> . string_decl decl
    (4) decl -> . var_decl decl
    (5) decl -> . empty
    (6) string_decl -> . STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
    (7) var_decl -> . var_type id_list SEMI
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    WRITE           reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    ENDWHILE        reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    string_decl                    shift and go to state 5
    var_type                       shift and go to state 6
    empty                          shift and go to state 11
    decl                           shift and go to state 121
    var_decl                       shift and go to state 8

state 112

    (58) mulop -> DIV .

    L_PAR           reduce using rule 58 (mulop -> DIV .)
    IDENTIFIER      reduce using rule 58 (mulop -> DIV .)
    INTLITERAL      reduce using rule 58 (mulop -> DIV .)
    FLOATLITERAL    reduce using rule 58 (mulop -> DIV .)


state 113

    (42) factor_prefix -> factor_prefix postfix_expr mulop .

    L_PAR           reduce using rule 42 (factor_prefix -> factor_prefix postfix_expr mulop .)
    IDENTIFIER      reduce using rule 42 (factor_prefix -> factor_prefix postfix_expr mulop .)
    INTLITERAL      reduce using rule 42 (factor_prefix -> factor_prefix postfix_expr mulop .)
    FLOATLITERAL    reduce using rule 42 (factor_prefix -> factor_prefix postfix_expr mulop .)


state 114

    (57) mulop -> MULT .

    L_PAR           reduce using rule 57 (mulop -> MULT .)
    IDENTIFIER      reduce using rule 57 (mulop -> MULT .)
    INTLITERAL      reduce using rule 57 (mulop -> MULT .)
    FLOATLITERAL    reduce using rule 57 (mulop -> MULT .)


state 115

    (51) primary -> L_PAR expr . R_PAR

    R_PAR           shift and go to state 122


state 116

    (46) call_expr -> IDENTIFIER L_PAR . expr_list R_PAR
    (47) expr_list -> . expr expr_list_tail
    (48) expr_list -> . empty
    (38) expr -> . expr_prefix factor
    (70) empty -> .
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty

    R_PAR           reduce using rule 70 (empty -> .)
    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    empty                          shift and go to state 124
    expr                           shift and go to state 123
    expr_list                      shift and go to state 125
    expr_prefix                    shift and go to state 73

state 117

    (35) read_stmt -> READ L_PAR id_list R_PAR SEMI .

    IF              reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    WHILE           reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    READ            reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    WRITE           reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    RETURN          reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    IDENTIFIER      reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    END             reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    ELSE            reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    ENDIF           reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    ENDWHILE        reduce using rule 35 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)


state 118

    (59) if_stmt -> IF L_PAR cond R_PAR decl . stmt_list else_part ENDIF
    (24) stmt_list -> . stmt stmt_list
    (25) stmt_list -> . empty
    (26) stmt -> . base_stmt
    (27) stmt -> . if_stmt
    (28) stmt -> . while_stmt
    (70) empty -> .
    (29) base_stmt -> . assign_stmt
    (30) base_stmt -> . read_stmt
    (31) base_stmt -> . write_stmt
    (32) base_stmt -> . return_stmt
    (59) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (69) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (33) assign_stmt -> . assign_expr SEMI
    (35) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (36) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (37) return_stmt -> . RETURN expr SEMI
    (34) assign_expr -> . IDENTIFIER EQ_EQ expr

    ELSE            reduce using rule 70 (empty -> .)
    ENDIF           reduce using rule 70 (empty -> .)
    IF              shift and go to state 62
    WHILE           shift and go to state 66
    READ            shift and go to state 56
    WRITE           shift and go to state 65
    RETURN          shift and go to state 55
    IDENTIFIER      shift and go to state 67

    base_stmt                      shift and go to state 63
    return_stmt                    shift and go to state 54
    while_stmt                     shift and go to state 64
    write_stmt                     shift and go to state 57
    assign_stmt                    shift and go to state 58
    assign_expr                    shift and go to state 59
    stmt                           shift and go to state 70
    empty                          shift and go to state 60
    stmt_list                      shift and go to state 126
    read_stmt                      shift and go to state 68
    if_stmt                        shift and go to state 69

state 119

    (62) cond -> expr compop expr .

    R_PAR           reduce using rule 62 (cond -> expr compop expr .)


state 120

    (36) write_stmt -> WRITE L_PAR id_list R_PAR SEMI .

    IF              reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    WHILE           reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    READ            reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    WRITE           reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    RETURN          reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    IDENTIFIER      reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    END             reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    ELSE            reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    ENDIF           reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    ENDWHILE        reduce using rule 36 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)


state 121

    (69) while_stmt -> WHILE L_PAR cond R_PAR decl . stmt_list ENDWHILE
    (24) stmt_list -> . stmt stmt_list
    (25) stmt_list -> . empty
    (26) stmt -> . base_stmt
    (27) stmt -> . if_stmt
    (28) stmt -> . while_stmt
    (70) empty -> .
    (29) base_stmt -> . assign_stmt
    (30) base_stmt -> . read_stmt
    (31) base_stmt -> . write_stmt
    (32) base_stmt -> . return_stmt
    (59) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (69) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (33) assign_stmt -> . assign_expr SEMI
    (35) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (36) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (37) return_stmt -> . RETURN expr SEMI
    (34) assign_expr -> . IDENTIFIER EQ_EQ expr

    ENDWHILE        reduce using rule 70 (empty -> .)
    IF              shift and go to state 62
    WHILE           shift and go to state 66
    READ            shift and go to state 56
    WRITE           shift and go to state 65
    RETURN          shift and go to state 55
    IDENTIFIER      shift and go to state 67

    base_stmt                      shift and go to state 63
    return_stmt                    shift and go to state 54
    while_stmt                     shift and go to state 64
    write_stmt                     shift and go to state 57
    assign_stmt                    shift and go to state 58
    assign_expr                    shift and go to state 59
    stmt                           shift and go to state 70
    empty                          shift and go to state 60
    stmt_list                      shift and go to state 127
    read_stmt                      shift and go to state 68
    if_stmt                        shift and go to state 69

state 122

    (51) primary -> L_PAR expr R_PAR .

    MULT            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    DIV             reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    PLUS            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    MINUS           reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    SEMI            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    LESS            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    MORE            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    EQ              reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    N_EQ            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    L_EQ            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    R_EQ            reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    R_PAR           reduce using rule 51 (primary -> L_PAR expr R_PAR .)
    COMM            reduce using rule 51 (primary -> L_PAR expr R_PAR .)


state 123

    (47) expr_list -> expr . expr_list_tail
    (49) expr_list_tail -> . COMM expr expr_list_tail
    (50) expr_list_tail -> . empty
    (70) empty -> .

    COMM            shift and go to state 129
    R_PAR           reduce using rule 70 (empty -> .)

    empty                          shift and go to state 128
    expr_list_tail                 shift and go to state 130

state 124

    (48) expr_list -> empty .
    (40) expr_prefix -> empty .

    R_PAR           reduce using rule 48 (expr_list -> empty .)
    L_PAR           reduce using rule 40 (expr_prefix -> empty .)
    IDENTIFIER      reduce using rule 40 (expr_prefix -> empty .)
    INTLITERAL      reduce using rule 40 (expr_prefix -> empty .)
    FLOATLITERAL    reduce using rule 40 (expr_prefix -> empty .)


state 125

    (46) call_expr -> IDENTIFIER L_PAR expr_list . R_PAR

    R_PAR           shift and go to state 131


state 126

    (59) if_stmt -> IF L_PAR cond R_PAR decl stmt_list . else_part ENDIF
    (60) else_part -> . ELSE decl stmt_list
    (61) else_part -> . empty
    (70) empty -> .

    ELSE            shift and go to state 134
    ENDIF           reduce using rule 70 (empty -> .)

    else_part                      shift and go to state 132
    empty                          shift and go to state 133

state 127

    (69) while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list . ENDWHILE

    ENDWHILE        shift and go to state 135


state 128

    (50) expr_list_tail -> empty .

    R_PAR           reduce using rule 50 (expr_list_tail -> empty .)


state 129

    (49) expr_list_tail -> COMM . expr expr_list_tail
    (38) expr -> . expr_prefix factor
    (39) expr_prefix -> . expr_prefix factor addop
    (40) expr_prefix -> . empty
    (70) empty -> .

    L_PAR           reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    INTLITERAL      reduce using rule 70 (empty -> .)
    FLOATLITERAL    reduce using rule 70 (empty -> .)

    expr                           shift and go to state 136
    empty                          shift and go to state 71
    expr_prefix                    shift and go to state 73

state 130

    (47) expr_list -> expr expr_list_tail .

    R_PAR           reduce using rule 47 (expr_list -> expr expr_list_tail .)


state 131

    (46) call_expr -> IDENTIFIER L_PAR expr_list R_PAR .

    MULT            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    DIV             reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    PLUS            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    MINUS           reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    SEMI            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    LESS            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    MORE            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    EQ              reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    N_EQ            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    L_EQ            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    R_EQ            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    R_PAR           reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)
    COMM            reduce using rule 46 (call_expr -> IDENTIFIER L_PAR expr_list R_PAR .)


state 132

    (59) if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part . ENDIF

    ENDIF           shift and go to state 137


state 133

    (61) else_part -> empty .

    ENDIF           reduce using rule 61 (else_part -> empty .)


state 134

    (60) else_part -> ELSE . decl stmt_list
    (3) decl -> . string_decl decl
    (4) decl -> . var_decl decl
    (5) decl -> . empty
    (6) string_decl -> . STRING IDENTIFIER EQ_EQ STRINGLITERAL SEMI
    (7) var_decl -> . var_type id_list SEMI
    (70) empty -> .
    (8) var_type -> . FLOAT
    (9) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    WRITE           reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    IDENTIFIER      reduce using rule 70 (empty -> .)
    ENDIF           reduce using rule 70 (empty -> .)
    FLOAT           shift and go to state 13
    INT             shift and go to state 7

    string_decl                    shift and go to state 5
    var_type                       shift and go to state 6
    empty                          shift and go to state 11
    decl                           shift and go to state 138
    var_decl                       shift and go to state 8

state 135

    (69) while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .

    IF              reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    WHILE           reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    READ            reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    WRITE           reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    RETURN          reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    IDENTIFIER      reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    END             reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    ELSE            reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    ENDIF           reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    ENDWHILE        reduce using rule 69 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)


state 136

    (49) expr_list_tail -> COMM expr . expr_list_tail
    (49) expr_list_tail -> . COMM expr expr_list_tail
    (50) expr_list_tail -> . empty
    (70) empty -> .

    COMM            shift and go to state 129
    R_PAR           reduce using rule 70 (empty -> .)

    empty                          shift and go to state 128
    expr_list_tail                 shift and go to state 139

state 137

    (59) if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .

    IF              reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    WHILE           reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    READ            reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    WRITE           reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    RETURN          reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    IDENTIFIER      reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    ELSE            reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    ENDIF           reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    END             reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    ENDWHILE        reduce using rule 59 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)


state 138

    (60) else_part -> ELSE decl . stmt_list
    (24) stmt_list -> . stmt stmt_list
    (25) stmt_list -> . empty
    (26) stmt -> . base_stmt
    (27) stmt -> . if_stmt
    (28) stmt -> . while_stmt
    (70) empty -> .
    (29) base_stmt -> . assign_stmt
    (30) base_stmt -> . read_stmt
    (31) base_stmt -> . write_stmt
    (32) base_stmt -> . return_stmt
    (59) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (69) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (33) assign_stmt -> . assign_expr SEMI
    (35) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (36) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (37) return_stmt -> . RETURN expr SEMI
    (34) assign_expr -> . IDENTIFIER EQ_EQ expr

    ENDIF           reduce using rule 70 (empty -> .)
    IF              shift and go to state 62
    WHILE           shift and go to state 66
    READ            shift and go to state 56
    WRITE           shift and go to state 65
    RETURN          shift and go to state 55
    IDENTIFIER      shift and go to state 67

    base_stmt                      shift and go to state 63
    return_stmt                    shift and go to state 54
    while_stmt                     shift and go to state 64
    write_stmt                     shift and go to state 57
    assign_stmt                    shift and go to state 58
    assign_expr                    shift and go to state 59
    stmt                           shift and go to state 70
    empty                          shift and go to state 60
    stmt_list                      shift and go to state 140
    read_stmt                      shift and go to state 68
    if_stmt                        shift and go to state 69

state 139

    (49) expr_list_tail -> COMM expr expr_list_tail .

    R_PAR           reduce using rule 49 (expr_list_tail -> COMM expr expr_list_tail .)


state 140

    (60) else_part -> ELSE decl stmt_list .

    ENDIF           reduce using rule 60 (else_part -> ELSE decl stmt_list .)

