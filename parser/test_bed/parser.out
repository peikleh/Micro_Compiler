Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CONTINUE
    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM id BEGIN pgm_body END
Rule 2     id -> IDENTIFIER
Rule 3     pgm_body -> decl func_declarations
Rule 4     decl -> string_decl decl
Rule 5     decl -> var_decl decl
Rule 6     decl -> empty
Rule 7     string_decl -> STRING id EQ_EQ str SEMI
Rule 8     str -> STRINGLITERAL
Rule 9     var_decl -> var_type id_list SEMI
Rule 10    var_type -> FLOAT
Rule 11    var_type -> INT
Rule 12    any_type -> var_type
Rule 13    any_type -> VOID
Rule 14    id_list -> id id_tail
Rule 15    id_tail -> COMM id id_tail
Rule 16    id_tail -> empty
Rule 17    param_decl_list -> param_decl param_decl_tail
Rule 18    param_decl_list -> empty
Rule 19    param_decl -> var_type id
Rule 20    param_decl_tail -> COMM param_decl param_decl_tail
Rule 21    param_decl_tail -> empty
Rule 22    func_declarations -> func_decl func_declarations
Rule 23    func_declarations -> empty
Rule 24    func_decl -> FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN func_body END
Rule 25    func_body -> decl stmt_list
Rule 26    stmt_list -> stmt stmt_list
Rule 27    stmt_list -> empty
Rule 28    stmt -> base_stmt
Rule 29    stmt -> if_stmt
Rule 30    stmt -> while_stmt
Rule 31    base_stmt -> assign_stmt
Rule 32    base_stmt -> read_stmt
Rule 33    base_stmt -> write_stmt
Rule 34    base_stmt -> return_stmt
Rule 35    assign_stmt -> assign_expr SEMI
Rule 36    assign_expr -> id EQ_EQ expr
Rule 37    read_stmt -> READ L_PAR id_list R_PAR SEMI
Rule 38    write_stmt -> WRITE L_PAR id_list R_PAR SEMI
Rule 39    return_stmt -> RETURN expr
Rule 40    expr -> expr_prefix factor
Rule 41    expr_prefix -> expr_prefix factor addop
Rule 42    expr_prefix -> empty
Rule 43    factor -> factor_prefix postfix_expr
Rule 44    factor_prefix -> factor_prefix postfix_expr mulop
Rule 45    factor_prefix -> empty
Rule 46    postfix_expr -> primary
Rule 47    postfix_expr -> call_expr
Rule 48    call_expr -> id L_PAR expr_list R_PAR
Rule 49    expr_list -> expr expr_list_tail
Rule 50    expr_list -> empty
Rule 51    expr_list_tail -> COMM expr expr_list_tail
Rule 52    expr_list_tail -> empty
Rule 53    primary -> L_PAR expr R_PAR
Rule 54    primary -> id
Rule 55    primary -> INTLITERAL
Rule 56    primary -> FLOATLITERAL
Rule 57    addop -> PLUS
Rule 58    addop -> MINUS
Rule 59    mulop -> MULT
Rule 60    mulop -> DIV
Rule 61    if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
Rule 62    else_part -> ELSE decl stmt_list
Rule 63    else_part -> empty
Rule 64    cond -> expr compop expr
Rule 65    compop -> LESS
Rule 66    compop -> MORE
Rule 67    compop -> EQ
Rule 68    compop -> N_EQ
Rule 69    compop -> L_EQ
Rule 70    compop -> R_EQ
Rule 71    while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE

Terminals, with rules where they appear

BEGIN                : 1 24
BREAK                : 
COMM                 : 15 20 51
COMMENT              : 
CONTINUE             : 
DIV                  : 60
ELSE                 : 62
END                  : 1 24
ENDIF                : 61
ENDWHILE             : 71
EQ                   : 67
EQ_EQ                : 7 36
FLOAT                : 10
FLOATLITERAL         : 56
FUNCTION             : 24
IDENTIFIER           : 2
IF                   : 61
INT                  : 11
INTLITERAL           : 55
LESS                 : 65
L_EQ                 : 69
L_PAR                : 24 37 38 48 53 61 71
MINUS                : 58
MORE                 : 66
MULT                 : 59
N_EQ                 : 68
PLUS                 : 57
PROGRAM              : 1
READ                 : 37
RETURN               : 39
R_EQ                 : 70
R_PAR                : 24 37 38 48 53 61 71
SEMI                 : 7 9 35 37 38
STRING               : 7
STRINGLITERAL        : 8
VOID                 : 13
WHILE                : 71
WRITE                : 38
empty                : 6 16 18 21 23 27 42 45 50 52 63
error                : 

Nonterminals, with rules where they appear

addop                : 41
any_type             : 24
assign_expr          : 35
assign_stmt          : 31
base_stmt            : 28
call_expr            : 47
compop               : 64
cond                 : 61 71
decl                 : 3 4 5 25 61 62 71
else_part            : 61
expr                 : 36 39 49 51 53 64 64
expr_list            : 48
expr_list_tail       : 49 51
expr_prefix          : 40 41
factor               : 40 41
factor_prefix        : 43 44
func_body            : 24
func_decl            : 22
func_declarations    : 3 22
id                   : 1 7 14 15 19 24 36 48 54
id_list              : 9 37 38
id_tail              : 14 15
if_stmt              : 29
mulop                : 44
param_decl           : 17 20
param_decl_list      : 24
param_decl_tail      : 17 20
pgm_body             : 1
postfix_expr         : 43 44
primary              : 46
program              : 0
read_stmt            : 32
return_stmt          : 34
stmt                 : 26
stmt_list            : 25 26 61 62 71
str                  : 7
string_decl          : 4
var_decl             : 5
var_type             : 9 12 19
while_stmt           : 30
write_stmt           : 33

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM id BEGIN pgm_body END

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . id BEGIN pgm_body END
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 3

state 2

    (0) S' -> program .



state 3

    (1) program -> PROGRAM id . BEGIN pgm_body END

    BEGIN           shift and go to state 5


state 4

    (2) id -> IDENTIFIER .

    EQ_EQ           reduce using rule 2 (id -> IDENTIFIER .)
    COMM            reduce using rule 2 (id -> IDENTIFIER .)
    empty           reduce using rule 2 (id -> IDENTIFIER .)
    BEGIN           reduce using rule 2 (id -> IDENTIFIER .)
    L_PAR           reduce using rule 2 (id -> IDENTIFIER .)
    MULT            reduce using rule 2 (id -> IDENTIFIER .)
    DIV             reduce using rule 2 (id -> IDENTIFIER .)
    PLUS            reduce using rule 2 (id -> IDENTIFIER .)
    MINUS           reduce using rule 2 (id -> IDENTIFIER .)
    IF              reduce using rule 2 (id -> IDENTIFIER .)
    WHILE           reduce using rule 2 (id -> IDENTIFIER .)
    READ            reduce using rule 2 (id -> IDENTIFIER .)
    WRITE           reduce using rule 2 (id -> IDENTIFIER .)
    RETURN          reduce using rule 2 (id -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 2 (id -> IDENTIFIER .)
    SEMI            reduce using rule 2 (id -> IDENTIFIER .)
    LESS            reduce using rule 2 (id -> IDENTIFIER .)
    MORE            reduce using rule 2 (id -> IDENTIFIER .)
    EQ              reduce using rule 2 (id -> IDENTIFIER .)
    N_EQ            reduce using rule 2 (id -> IDENTIFIER .)
    L_EQ            reduce using rule 2 (id -> IDENTIFIER .)
    R_EQ            reduce using rule 2 (id -> IDENTIFIER .)
    R_PAR           reduce using rule 2 (id -> IDENTIFIER .)


state 5

    (1) program -> PROGRAM id BEGIN . pgm_body END
    (3) pgm_body -> . decl func_declarations
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id EQ_EQ str SEMI
    (9) var_decl -> . var_type id_list SEMI
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 8
    STRING          shift and go to state 9
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 7
    decl                           shift and go to state 10
    string_decl                    shift and go to state 11
    var_decl                       shift and go to state 12
    pgm_body                       shift and go to state 13

state 6

    (11) var_type -> INT .

    IDENTIFIER      reduce using rule 11 (var_type -> INT .)


state 7

    (9) var_decl -> var_type . id_list SEMI
    (14) id_list -> . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 15
    id_list                        shift and go to state 16

state 8

    (6) decl -> empty .

    empty           reduce using rule 6 (decl -> empty .)
    IF              reduce using rule 6 (decl -> empty .)
    WHILE           reduce using rule 6 (decl -> empty .)
    READ            reduce using rule 6 (decl -> empty .)
    WRITE           reduce using rule 6 (decl -> empty .)
    RETURN          reduce using rule 6 (decl -> empty .)
    IDENTIFIER      reduce using rule 6 (decl -> empty .)
    FUNCTION        reduce using rule 6 (decl -> empty .)


state 9

    (7) string_decl -> STRING . id EQ_EQ str SEMI
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 17

state 10

    (3) pgm_body -> decl . func_declarations
    (22) func_declarations -> . func_decl func_declarations
    (23) func_declarations -> . empty
    (24) func_decl -> . FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN func_body END

    empty           shift and go to state 21
    FUNCTION        shift and go to state 19

    func_declarations              shift and go to state 18
    func_decl                      shift and go to state 20

state 11

    (4) decl -> string_decl . decl
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id EQ_EQ str SEMI
    (9) var_decl -> . var_type id_list SEMI
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 8
    STRING          shift and go to state 9
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 7
    decl                           shift and go to state 22
    string_decl                    shift and go to state 11
    var_decl                       shift and go to state 12

state 12

    (5) decl -> var_decl . decl
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id EQ_EQ str SEMI
    (9) var_decl -> . var_type id_list SEMI
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 8
    STRING          shift and go to state 9
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 7
    decl                           shift and go to state 23
    string_decl                    shift and go to state 11
    var_decl                       shift and go to state 12

state 13

    (1) program -> PROGRAM id BEGIN pgm_body . END

    END             shift and go to state 24


state 14

    (10) var_type -> FLOAT .

    IDENTIFIER      reduce using rule 10 (var_type -> FLOAT .)


state 15

    (14) id_list -> id . id_tail
    (15) id_tail -> . COMM id id_tail
    (16) id_tail -> . empty

    COMM            shift and go to state 27
    empty           shift and go to state 25

    id_tail                        shift and go to state 26

state 16

    (9) var_decl -> var_type id_list . SEMI

    SEMI            shift and go to state 28


state 17

    (7) string_decl -> STRING id . EQ_EQ str SEMI

    EQ_EQ           shift and go to state 29


state 18

    (3) pgm_body -> decl func_declarations .

    END             reduce using rule 3 (pgm_body -> decl func_declarations .)


state 19

    (24) func_decl -> FUNCTION . any_type id L_PAR param_decl_list R_PAR BEGIN func_body END
    (12) any_type -> . var_type
    (13) any_type -> . VOID
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    VOID            shift and go to state 31
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 30
    any_type                       shift and go to state 32

state 20

    (22) func_declarations -> func_decl . func_declarations
    (22) func_declarations -> . func_decl func_declarations
    (23) func_declarations -> . empty
    (24) func_decl -> . FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN func_body END

    empty           shift and go to state 21
    FUNCTION        shift and go to state 19

    func_declarations              shift and go to state 33
    func_decl                      shift and go to state 20

state 21

    (23) func_declarations -> empty .

    END             reduce using rule 23 (func_declarations -> empty .)


state 22

    (4) decl -> string_decl decl .

    empty           reduce using rule 4 (decl -> string_decl decl .)
    IF              reduce using rule 4 (decl -> string_decl decl .)
    WHILE           reduce using rule 4 (decl -> string_decl decl .)
    READ            reduce using rule 4 (decl -> string_decl decl .)
    WRITE           reduce using rule 4 (decl -> string_decl decl .)
    RETURN          reduce using rule 4 (decl -> string_decl decl .)
    IDENTIFIER      reduce using rule 4 (decl -> string_decl decl .)
    FUNCTION        reduce using rule 4 (decl -> string_decl decl .)


state 23

    (5) decl -> var_decl decl .

    empty           reduce using rule 5 (decl -> var_decl decl .)
    IF              reduce using rule 5 (decl -> var_decl decl .)
    WHILE           reduce using rule 5 (decl -> var_decl decl .)
    READ            reduce using rule 5 (decl -> var_decl decl .)
    WRITE           reduce using rule 5 (decl -> var_decl decl .)
    RETURN          reduce using rule 5 (decl -> var_decl decl .)
    IDENTIFIER      reduce using rule 5 (decl -> var_decl decl .)
    FUNCTION        reduce using rule 5 (decl -> var_decl decl .)


state 24

    (1) program -> PROGRAM id BEGIN pgm_body END .

    $end            reduce using rule 1 (program -> PROGRAM id BEGIN pgm_body END .)


state 25

    (16) id_tail -> empty .

    SEMI            reduce using rule 16 (id_tail -> empty .)
    R_PAR           reduce using rule 16 (id_tail -> empty .)


state 26

    (14) id_list -> id id_tail .

    SEMI            reduce using rule 14 (id_list -> id id_tail .)
    R_PAR           reduce using rule 14 (id_list -> id id_tail .)


state 27

    (15) id_tail -> COMM . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 34

state 28

    (9) var_decl -> var_type id_list SEMI .

    empty           reduce using rule 9 (var_decl -> var_type id_list SEMI .)
    STRING          reduce using rule 9 (var_decl -> var_type id_list SEMI .)
    FLOAT           reduce using rule 9 (var_decl -> var_type id_list SEMI .)
    INT             reduce using rule 9 (var_decl -> var_type id_list SEMI .)


state 29

    (7) string_decl -> STRING id EQ_EQ . str SEMI
    (8) str -> . STRINGLITERAL

    STRINGLITERAL   shift and go to state 35

    str                            shift and go to state 36

state 30

    (12) any_type -> var_type .

    IDENTIFIER      reduce using rule 12 (any_type -> var_type .)


state 31

    (13) any_type -> VOID .

    IDENTIFIER      reduce using rule 13 (any_type -> VOID .)


state 32

    (24) func_decl -> FUNCTION any_type . id L_PAR param_decl_list R_PAR BEGIN func_body END
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 37

state 33

    (22) func_declarations -> func_decl func_declarations .

    END             reduce using rule 22 (func_declarations -> func_decl func_declarations .)


state 34

    (15) id_tail -> COMM id . id_tail
    (15) id_tail -> . COMM id id_tail
    (16) id_tail -> . empty

    COMM            shift and go to state 27
    empty           shift and go to state 25

    id_tail                        shift and go to state 38

state 35

    (8) str -> STRINGLITERAL .

    SEMI            reduce using rule 8 (str -> STRINGLITERAL .)


state 36

    (7) string_decl -> STRING id EQ_EQ str . SEMI

    SEMI            shift and go to state 39


state 37

    (24) func_decl -> FUNCTION any_type id . L_PAR param_decl_list R_PAR BEGIN func_body END

    L_PAR           shift and go to state 40


state 38

    (15) id_tail -> COMM id id_tail .

    SEMI            reduce using rule 15 (id_tail -> COMM id id_tail .)
    R_PAR           reduce using rule 15 (id_tail -> COMM id id_tail .)


state 39

    (7) string_decl -> STRING id EQ_EQ str SEMI .

    empty           reduce using rule 7 (string_decl -> STRING id EQ_EQ str SEMI .)
    STRING          reduce using rule 7 (string_decl -> STRING id EQ_EQ str SEMI .)
    FLOAT           reduce using rule 7 (string_decl -> STRING id EQ_EQ str SEMI .)
    INT             reduce using rule 7 (string_decl -> STRING id EQ_EQ str SEMI .)


state 40

    (24) func_decl -> FUNCTION any_type id L_PAR . param_decl_list R_PAR BEGIN func_body END
    (17) param_decl_list -> . param_decl param_decl_tail
    (18) param_decl_list -> . empty
    (19) param_decl -> . var_type id
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 43
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 42
    param_decl                     shift and go to state 41
    param_decl_list                shift and go to state 44

state 41

    (17) param_decl_list -> param_decl . param_decl_tail
    (20) param_decl_tail -> . COMM param_decl param_decl_tail
    (21) param_decl_tail -> . empty

    COMM            shift and go to state 46
    empty           shift and go to state 45

    param_decl_tail                shift and go to state 47

state 42

    (19) param_decl -> var_type . id
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 48

state 43

    (18) param_decl_list -> empty .

    R_PAR           reduce using rule 18 (param_decl_list -> empty .)


state 44

    (24) func_decl -> FUNCTION any_type id L_PAR param_decl_list . R_PAR BEGIN func_body END

    R_PAR           shift and go to state 49


state 45

    (21) param_decl_tail -> empty .

    R_PAR           reduce using rule 21 (param_decl_tail -> empty .)


state 46

    (20) param_decl_tail -> COMM . param_decl param_decl_tail
    (19) param_decl -> . var_type id
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 42
    param_decl                     shift and go to state 50

state 47

    (17) param_decl_list -> param_decl param_decl_tail .

    R_PAR           reduce using rule 17 (param_decl_list -> param_decl param_decl_tail .)


state 48

    (19) param_decl -> var_type id .

    COMM            reduce using rule 19 (param_decl -> var_type id .)
    empty           reduce using rule 19 (param_decl -> var_type id .)


state 49

    (24) func_decl -> FUNCTION any_type id L_PAR param_decl_list R_PAR . BEGIN func_body END

    BEGIN           shift and go to state 51


state 50

    (20) param_decl_tail -> COMM param_decl . param_decl_tail
    (20) param_decl_tail -> . COMM param_decl param_decl_tail
    (21) param_decl_tail -> . empty

    COMM            shift and go to state 46
    empty           shift and go to state 45

    param_decl_tail                shift and go to state 52

state 51

    (24) func_decl -> FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN . func_body END
    (25) func_body -> . decl stmt_list
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id EQ_EQ str SEMI
    (9) var_decl -> . var_type id_list SEMI
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 8
    STRING          shift and go to state 9
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    string_decl                    shift and go to state 11
    decl                           shift and go to state 54
    var_decl                       shift and go to state 12
    func_body                      shift and go to state 53
    var_type                       shift and go to state 7

state 52

    (20) param_decl_tail -> COMM param_decl param_decl_tail .

    R_PAR           reduce using rule 20 (param_decl_tail -> COMM param_decl param_decl_tail .)


state 53

    (24) func_decl -> FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN func_body . END

    END             shift and go to state 55


state 54

    (25) func_body -> decl . stmt_list
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMI
    (37) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (38) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (39) return_stmt -> . RETURN expr
    (36) assign_expr -> . id EQ_EQ expr
    (2) id -> . IDENTIFIER

    empty           shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 66
    READ            shift and go to state 60
    WRITE           shift and go to state 70
    RETURN          shift and go to state 58
    IDENTIFIER      shift and go to state 4

    while_stmt                     shift and go to state 56
    return_stmt                    shift and go to state 57
    assign_stmt                    shift and go to state 59
    write_stmt                     shift and go to state 67
    id                             shift and go to state 62
    assign_expr                    shift and go to state 69
    base_stmt                      shift and go to state 63
    stmt                           shift and go to state 65
    read_stmt                      shift and go to state 64
    if_stmt                        shift and go to state 71
    stmt_list                      shift and go to state 72

state 55

    (24) func_decl -> FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN func_body END .

    empty           reduce using rule 24 (func_decl -> FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN func_body END .)
    FUNCTION        reduce using rule 24 (func_decl -> FUNCTION any_type id L_PAR param_decl_list R_PAR BEGIN func_body END .)


state 56

    (30) stmt -> while_stmt .

    empty           reduce using rule 30 (stmt -> while_stmt .)
    IF              reduce using rule 30 (stmt -> while_stmt .)
    WHILE           reduce using rule 30 (stmt -> while_stmt .)
    READ            reduce using rule 30 (stmt -> while_stmt .)
    WRITE           reduce using rule 30 (stmt -> while_stmt .)
    RETURN          reduce using rule 30 (stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 30 (stmt -> while_stmt .)


state 57

    (34) base_stmt -> return_stmt .

    empty           reduce using rule 34 (base_stmt -> return_stmt .)
    IF              reduce using rule 34 (base_stmt -> return_stmt .)
    WHILE           reduce using rule 34 (base_stmt -> return_stmt .)
    READ            reduce using rule 34 (base_stmt -> return_stmt .)
    WRITE           reduce using rule 34 (base_stmt -> return_stmt .)
    RETURN          reduce using rule 34 (base_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 34 (base_stmt -> return_stmt .)


state 58

    (39) return_stmt -> RETURN . expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 73

    expr                           shift and go to state 74
    expr_prefix                    shift and go to state 75

state 59

    (31) base_stmt -> assign_stmt .

    empty           reduce using rule 31 (base_stmt -> assign_stmt .)
    IF              reduce using rule 31 (base_stmt -> assign_stmt .)
    WHILE           reduce using rule 31 (base_stmt -> assign_stmt .)
    READ            reduce using rule 31 (base_stmt -> assign_stmt .)
    WRITE           reduce using rule 31 (base_stmt -> assign_stmt .)
    RETURN          reduce using rule 31 (base_stmt -> assign_stmt .)
    IDENTIFIER      reduce using rule 31 (base_stmt -> assign_stmt .)


state 60

    (37) read_stmt -> READ . L_PAR id_list R_PAR SEMI

    L_PAR           shift and go to state 76


state 61

    (27) stmt_list -> empty .

    ENDWHILE        reduce using rule 27 (stmt_list -> empty .)
    ENDIF           reduce using rule 27 (stmt_list -> empty .)
    END             reduce using rule 27 (stmt_list -> empty .)
    ELSE            reduce using rule 27 (stmt_list -> empty .)
    empty           reduce using rule 27 (stmt_list -> empty .)


state 62

    (36) assign_expr -> id . EQ_EQ expr

    EQ_EQ           shift and go to state 77


state 63

    (28) stmt -> base_stmt .

    empty           reduce using rule 28 (stmt -> base_stmt .)
    IF              reduce using rule 28 (stmt -> base_stmt .)
    WHILE           reduce using rule 28 (stmt -> base_stmt .)
    READ            reduce using rule 28 (stmt -> base_stmt .)
    WRITE           reduce using rule 28 (stmt -> base_stmt .)
    RETURN          reduce using rule 28 (stmt -> base_stmt .)
    IDENTIFIER      reduce using rule 28 (stmt -> base_stmt .)


state 64

    (32) base_stmt -> read_stmt .

    empty           reduce using rule 32 (base_stmt -> read_stmt .)
    IF              reduce using rule 32 (base_stmt -> read_stmt .)
    WHILE           reduce using rule 32 (base_stmt -> read_stmt .)
    READ            reduce using rule 32 (base_stmt -> read_stmt .)
    WRITE           reduce using rule 32 (base_stmt -> read_stmt .)
    RETURN          reduce using rule 32 (base_stmt -> read_stmt .)
    IDENTIFIER      reduce using rule 32 (base_stmt -> read_stmt .)


state 65

    (26) stmt_list -> stmt . stmt_list
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMI
    (37) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (38) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (39) return_stmt -> . RETURN expr
    (36) assign_expr -> . id EQ_EQ expr
    (2) id -> . IDENTIFIER

    empty           shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 66
    READ            shift and go to state 60
    WRITE           shift and go to state 70
    RETURN          shift and go to state 58
    IDENTIFIER      shift and go to state 4

    while_stmt                     shift and go to state 56
    return_stmt                    shift and go to state 57
    assign_stmt                    shift and go to state 59
    write_stmt                     shift and go to state 67
    id                             shift and go to state 62
    assign_expr                    shift and go to state 69
    base_stmt                      shift and go to state 63
    stmt                           shift and go to state 65
    read_stmt                      shift and go to state 64
    if_stmt                        shift and go to state 71
    stmt_list                      shift and go to state 78

state 66

    (71) while_stmt -> WHILE . L_PAR cond R_PAR decl stmt_list ENDWHILE

    L_PAR           shift and go to state 79


state 67

    (33) base_stmt -> write_stmt .

    empty           reduce using rule 33 (base_stmt -> write_stmt .)
    IF              reduce using rule 33 (base_stmt -> write_stmt .)
    WHILE           reduce using rule 33 (base_stmt -> write_stmt .)
    READ            reduce using rule 33 (base_stmt -> write_stmt .)
    WRITE           reduce using rule 33 (base_stmt -> write_stmt .)
    RETURN          reduce using rule 33 (base_stmt -> write_stmt .)
    IDENTIFIER      reduce using rule 33 (base_stmt -> write_stmt .)


state 68

    (61) if_stmt -> IF . L_PAR cond R_PAR decl stmt_list else_part ENDIF

    L_PAR           shift and go to state 80


state 69

    (35) assign_stmt -> assign_expr . SEMI

    SEMI            shift and go to state 81


state 70

    (38) write_stmt -> WRITE . L_PAR id_list R_PAR SEMI

    L_PAR           shift and go to state 82


state 71

    (29) stmt -> if_stmt .

    empty           reduce using rule 29 (stmt -> if_stmt .)
    IF              reduce using rule 29 (stmt -> if_stmt .)
    WHILE           reduce using rule 29 (stmt -> if_stmt .)
    READ            reduce using rule 29 (stmt -> if_stmt .)
    WRITE           reduce using rule 29 (stmt -> if_stmt .)
    RETURN          reduce using rule 29 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 29 (stmt -> if_stmt .)


state 72

    (25) func_body -> decl stmt_list .

    END             reduce using rule 25 (func_body -> decl stmt_list .)


state 73

    (42) expr_prefix -> empty .

    empty           reduce using rule 42 (expr_prefix -> empty .)


state 74

    (39) return_stmt -> RETURN expr .

    empty           reduce using rule 39 (return_stmt -> RETURN expr .)
    IF              reduce using rule 39 (return_stmt -> RETURN expr .)
    WHILE           reduce using rule 39 (return_stmt -> RETURN expr .)
    READ            reduce using rule 39 (return_stmt -> RETURN expr .)
    WRITE           reduce using rule 39 (return_stmt -> RETURN expr .)
    RETURN          reduce using rule 39 (return_stmt -> RETURN expr .)
    IDENTIFIER      reduce using rule 39 (return_stmt -> RETURN expr .)


state 75

    (40) expr -> expr_prefix . factor
    (41) expr_prefix -> expr_prefix . factor addop
    (43) factor -> . factor_prefix postfix_expr
    (44) factor_prefix -> . factor_prefix postfix_expr mulop
    (45) factor_prefix -> . empty

    empty           shift and go to state 83

    factor                         shift and go to state 84
    factor_prefix                  shift and go to state 85

state 76

    (37) read_stmt -> READ L_PAR . id_list R_PAR SEMI
    (14) id_list -> . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 15
    id_list                        shift and go to state 86

state 77

    (36) assign_expr -> id EQ_EQ . expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 73

    expr                           shift and go to state 87
    expr_prefix                    shift and go to state 75

state 78

    (26) stmt_list -> stmt stmt_list .

    ENDWHILE        reduce using rule 26 (stmt_list -> stmt stmt_list .)
    ENDIF           reduce using rule 26 (stmt_list -> stmt stmt_list .)
    END             reduce using rule 26 (stmt_list -> stmt stmt_list .)
    ELSE            reduce using rule 26 (stmt_list -> stmt stmt_list .)
    empty           reduce using rule 26 (stmt_list -> stmt stmt_list .)


state 79

    (71) while_stmt -> WHILE L_PAR . cond R_PAR decl stmt_list ENDWHILE
    (64) cond -> . expr compop expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 73

    cond                           shift and go to state 88
    expr_prefix                    shift and go to state 75
    expr                           shift and go to state 89

state 80

    (61) if_stmt -> IF L_PAR . cond R_PAR decl stmt_list else_part ENDIF
    (64) cond -> . expr compop expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 73

    cond                           shift and go to state 90
    expr_prefix                    shift and go to state 75
    expr                           shift and go to state 89

state 81

    (35) assign_stmt -> assign_expr SEMI .

    empty           reduce using rule 35 (assign_stmt -> assign_expr SEMI .)
    IF              reduce using rule 35 (assign_stmt -> assign_expr SEMI .)
    WHILE           reduce using rule 35 (assign_stmt -> assign_expr SEMI .)
    READ            reduce using rule 35 (assign_stmt -> assign_expr SEMI .)
    WRITE           reduce using rule 35 (assign_stmt -> assign_expr SEMI .)
    RETURN          reduce using rule 35 (assign_stmt -> assign_expr SEMI .)
    IDENTIFIER      reduce using rule 35 (assign_stmt -> assign_expr SEMI .)


state 82

    (38) write_stmt -> WRITE L_PAR . id_list R_PAR SEMI
    (14) id_list -> . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    id                             shift and go to state 15
    id_list                        shift and go to state 91

state 83

    (45) factor_prefix -> empty .

    L_PAR           reduce using rule 45 (factor_prefix -> empty .)
    INTLITERAL      reduce using rule 45 (factor_prefix -> empty .)
    FLOATLITERAL    reduce using rule 45 (factor_prefix -> empty .)
    IDENTIFIER      reduce using rule 45 (factor_prefix -> empty .)


state 84

    (40) expr -> expr_prefix factor .
    (41) expr_prefix -> expr_prefix factor . addop
    (57) addop -> . PLUS
    (58) addop -> . MINUS

    COMM            reduce using rule 40 (expr -> expr_prefix factor .)
    empty           reduce using rule 40 (expr -> expr_prefix factor .)
    LESS            reduce using rule 40 (expr -> expr_prefix factor .)
    MORE            reduce using rule 40 (expr -> expr_prefix factor .)
    EQ              reduce using rule 40 (expr -> expr_prefix factor .)
    N_EQ            reduce using rule 40 (expr -> expr_prefix factor .)
    L_EQ            reduce using rule 40 (expr -> expr_prefix factor .)
    R_EQ            reduce using rule 40 (expr -> expr_prefix factor .)
    R_PAR           reduce using rule 40 (expr -> expr_prefix factor .)
    SEMI            reduce using rule 40 (expr -> expr_prefix factor .)
    IF              reduce using rule 40 (expr -> expr_prefix factor .)
    WHILE           reduce using rule 40 (expr -> expr_prefix factor .)
    READ            reduce using rule 40 (expr -> expr_prefix factor .)
    WRITE           reduce using rule 40 (expr -> expr_prefix factor .)
    RETURN          reduce using rule 40 (expr -> expr_prefix factor .)
    IDENTIFIER      reduce using rule 40 (expr -> expr_prefix factor .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 93

    addop                          shift and go to state 92

state 85

    (43) factor -> factor_prefix . postfix_expr
    (44) factor_prefix -> factor_prefix . postfix_expr mulop
    (46) postfix_expr -> . primary
    (47) postfix_expr -> . call_expr
    (53) primary -> . L_PAR expr R_PAR
    (54) primary -> . id
    (55) primary -> . INTLITERAL
    (56) primary -> . FLOATLITERAL
    (48) call_expr -> . id L_PAR expr_list R_PAR
    (2) id -> . IDENTIFIER

    L_PAR           shift and go to state 99
    INTLITERAL      shift and go to state 97
    FLOATLITERAL    shift and go to state 101
    IDENTIFIER      shift and go to state 4

    primary                        shift and go to state 100
    id                             shift and go to state 95
    call_expr                      shift and go to state 96
    postfix_expr                   shift and go to state 98

state 86

    (37) read_stmt -> READ L_PAR id_list . R_PAR SEMI

    R_PAR           shift and go to state 102


state 87

    (36) assign_expr -> id EQ_EQ expr .

    SEMI            reduce using rule 36 (assign_expr -> id EQ_EQ expr .)


state 88

    (71) while_stmt -> WHILE L_PAR cond . R_PAR decl stmt_list ENDWHILE

    R_PAR           shift and go to state 103


state 89

    (64) cond -> expr . compop expr
    (65) compop -> . LESS
    (66) compop -> . MORE
    (67) compop -> . EQ
    (68) compop -> . N_EQ
    (69) compop -> . L_EQ
    (70) compop -> . R_EQ

    LESS            shift and go to state 109
    MORE            shift and go to state 108
    EQ              shift and go to state 104
    N_EQ            shift and go to state 107
    L_EQ            shift and go to state 110
    R_EQ            shift and go to state 105

    compop                         shift and go to state 106

state 90

    (61) if_stmt -> IF L_PAR cond . R_PAR decl stmt_list else_part ENDIF

    R_PAR           shift and go to state 111


state 91

    (38) write_stmt -> WRITE L_PAR id_list . R_PAR SEMI

    R_PAR           shift and go to state 112


state 92

    (41) expr_prefix -> expr_prefix factor addop .

    empty           reduce using rule 41 (expr_prefix -> expr_prefix factor addop .)


state 93

    (58) addop -> MINUS .

    empty           reduce using rule 58 (addop -> MINUS .)


state 94

    (57) addop -> PLUS .

    empty           reduce using rule 57 (addop -> PLUS .)


state 95

    (54) primary -> id .
    (48) call_expr -> id . L_PAR expr_list R_PAR

    MULT            reduce using rule 54 (primary -> id .)
    DIV             reduce using rule 54 (primary -> id .)
    PLUS            reduce using rule 54 (primary -> id .)
    MINUS           reduce using rule 54 (primary -> id .)
    empty           reduce using rule 54 (primary -> id .)
    IF              reduce using rule 54 (primary -> id .)
    WHILE           reduce using rule 54 (primary -> id .)
    READ            reduce using rule 54 (primary -> id .)
    WRITE           reduce using rule 54 (primary -> id .)
    RETURN          reduce using rule 54 (primary -> id .)
    IDENTIFIER      reduce using rule 54 (primary -> id .)
    SEMI            reduce using rule 54 (primary -> id .)
    LESS            reduce using rule 54 (primary -> id .)
    MORE            reduce using rule 54 (primary -> id .)
    EQ              reduce using rule 54 (primary -> id .)
    N_EQ            reduce using rule 54 (primary -> id .)
    L_EQ            reduce using rule 54 (primary -> id .)
    R_EQ            reduce using rule 54 (primary -> id .)
    R_PAR           reduce using rule 54 (primary -> id .)
    COMM            reduce using rule 54 (primary -> id .)
    L_PAR           shift and go to state 113


state 96

    (47) postfix_expr -> call_expr .

    MULT            reduce using rule 47 (postfix_expr -> call_expr .)
    DIV             reduce using rule 47 (postfix_expr -> call_expr .)
    PLUS            reduce using rule 47 (postfix_expr -> call_expr .)
    MINUS           reduce using rule 47 (postfix_expr -> call_expr .)
    empty           reduce using rule 47 (postfix_expr -> call_expr .)
    IF              reduce using rule 47 (postfix_expr -> call_expr .)
    WHILE           reduce using rule 47 (postfix_expr -> call_expr .)
    READ            reduce using rule 47 (postfix_expr -> call_expr .)
    WRITE           reduce using rule 47 (postfix_expr -> call_expr .)
    RETURN          reduce using rule 47 (postfix_expr -> call_expr .)
    IDENTIFIER      reduce using rule 47 (postfix_expr -> call_expr .)
    SEMI            reduce using rule 47 (postfix_expr -> call_expr .)
    LESS            reduce using rule 47 (postfix_expr -> call_expr .)
    MORE            reduce using rule 47 (postfix_expr -> call_expr .)
    EQ              reduce using rule 47 (postfix_expr -> call_expr .)
    N_EQ            reduce using rule 47 (postfix_expr -> call_expr .)
    L_EQ            reduce using rule 47 (postfix_expr -> call_expr .)
    R_EQ            reduce using rule 47 (postfix_expr -> call_expr .)
    R_PAR           reduce using rule 47 (postfix_expr -> call_expr .)
    COMM            reduce using rule 47 (postfix_expr -> call_expr .)


state 97

    (55) primary -> INTLITERAL .

    MULT            reduce using rule 55 (primary -> INTLITERAL .)
    DIV             reduce using rule 55 (primary -> INTLITERAL .)
    PLUS            reduce using rule 55 (primary -> INTLITERAL .)
    MINUS           reduce using rule 55 (primary -> INTLITERAL .)
    empty           reduce using rule 55 (primary -> INTLITERAL .)
    IF              reduce using rule 55 (primary -> INTLITERAL .)
    WHILE           reduce using rule 55 (primary -> INTLITERAL .)
    READ            reduce using rule 55 (primary -> INTLITERAL .)
    WRITE           reduce using rule 55 (primary -> INTLITERAL .)
    RETURN          reduce using rule 55 (primary -> INTLITERAL .)
    IDENTIFIER      reduce using rule 55 (primary -> INTLITERAL .)
    SEMI            reduce using rule 55 (primary -> INTLITERAL .)
    LESS            reduce using rule 55 (primary -> INTLITERAL .)
    MORE            reduce using rule 55 (primary -> INTLITERAL .)
    EQ              reduce using rule 55 (primary -> INTLITERAL .)
    N_EQ            reduce using rule 55 (primary -> INTLITERAL .)
    L_EQ            reduce using rule 55 (primary -> INTLITERAL .)
    R_EQ            reduce using rule 55 (primary -> INTLITERAL .)
    R_PAR           reduce using rule 55 (primary -> INTLITERAL .)
    COMM            reduce using rule 55 (primary -> INTLITERAL .)


state 98

    (43) factor -> factor_prefix postfix_expr .
    (44) factor_prefix -> factor_prefix postfix_expr . mulop
    (59) mulop -> . MULT
    (60) mulop -> . DIV

    PLUS            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    MINUS           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    empty           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    IF              reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    WHILE           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    READ            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    WRITE           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    RETURN          reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    IDENTIFIER      reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    SEMI            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    LESS            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    MORE            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    EQ              reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    N_EQ            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    L_EQ            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    R_EQ            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    R_PAR           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    COMM            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    MULT            shift and go to state 114
    DIV             shift and go to state 116

    mulop                          shift and go to state 115

state 99

    (53) primary -> L_PAR . expr R_PAR
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 73

    expr                           shift and go to state 117
    expr_prefix                    shift and go to state 75

state 100

    (46) postfix_expr -> primary .

    MULT            reduce using rule 46 (postfix_expr -> primary .)
    DIV             reduce using rule 46 (postfix_expr -> primary .)
    PLUS            reduce using rule 46 (postfix_expr -> primary .)
    MINUS           reduce using rule 46 (postfix_expr -> primary .)
    empty           reduce using rule 46 (postfix_expr -> primary .)
    IF              reduce using rule 46 (postfix_expr -> primary .)
    WHILE           reduce using rule 46 (postfix_expr -> primary .)
    READ            reduce using rule 46 (postfix_expr -> primary .)
    WRITE           reduce using rule 46 (postfix_expr -> primary .)
    RETURN          reduce using rule 46 (postfix_expr -> primary .)
    IDENTIFIER      reduce using rule 46 (postfix_expr -> primary .)
    SEMI            reduce using rule 46 (postfix_expr -> primary .)
    LESS            reduce using rule 46 (postfix_expr -> primary .)
    MORE            reduce using rule 46 (postfix_expr -> primary .)
    EQ              reduce using rule 46 (postfix_expr -> primary .)
    N_EQ            reduce using rule 46 (postfix_expr -> primary .)
    L_EQ            reduce using rule 46 (postfix_expr -> primary .)
    R_EQ            reduce using rule 46 (postfix_expr -> primary .)
    R_PAR           reduce using rule 46 (postfix_expr -> primary .)
    COMM            reduce using rule 46 (postfix_expr -> primary .)


state 101

    (56) primary -> FLOATLITERAL .

    MULT            reduce using rule 56 (primary -> FLOATLITERAL .)
    DIV             reduce using rule 56 (primary -> FLOATLITERAL .)
    PLUS            reduce using rule 56 (primary -> FLOATLITERAL .)
    MINUS           reduce using rule 56 (primary -> FLOATLITERAL .)
    empty           reduce using rule 56 (primary -> FLOATLITERAL .)
    IF              reduce using rule 56 (primary -> FLOATLITERAL .)
    WHILE           reduce using rule 56 (primary -> FLOATLITERAL .)
    READ            reduce using rule 56 (primary -> FLOATLITERAL .)
    WRITE           reduce using rule 56 (primary -> FLOATLITERAL .)
    RETURN          reduce using rule 56 (primary -> FLOATLITERAL .)
    IDENTIFIER      reduce using rule 56 (primary -> FLOATLITERAL .)
    SEMI            reduce using rule 56 (primary -> FLOATLITERAL .)
    LESS            reduce using rule 56 (primary -> FLOATLITERAL .)
    MORE            reduce using rule 56 (primary -> FLOATLITERAL .)
    EQ              reduce using rule 56 (primary -> FLOATLITERAL .)
    N_EQ            reduce using rule 56 (primary -> FLOATLITERAL .)
    L_EQ            reduce using rule 56 (primary -> FLOATLITERAL .)
    R_EQ            reduce using rule 56 (primary -> FLOATLITERAL .)
    R_PAR           reduce using rule 56 (primary -> FLOATLITERAL .)
    COMM            reduce using rule 56 (primary -> FLOATLITERAL .)


state 102

    (37) read_stmt -> READ L_PAR id_list R_PAR . SEMI

    SEMI            shift and go to state 118


state 103

    (71) while_stmt -> WHILE L_PAR cond R_PAR . decl stmt_list ENDWHILE
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id EQ_EQ str SEMI
    (9) var_decl -> . var_type id_list SEMI
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 8
    STRING          shift and go to state 9
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 7
    decl                           shift and go to state 119
    string_decl                    shift and go to state 11
    var_decl                       shift and go to state 12

state 104

    (67) compop -> EQ .

    empty           reduce using rule 67 (compop -> EQ .)


state 105

    (70) compop -> R_EQ .

    empty           reduce using rule 70 (compop -> R_EQ .)


state 106

    (64) cond -> expr compop . expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 73

    expr                           shift and go to state 120
    expr_prefix                    shift and go to state 75

state 107

    (68) compop -> N_EQ .

    empty           reduce using rule 68 (compop -> N_EQ .)


state 108

    (66) compop -> MORE .

    empty           reduce using rule 66 (compop -> MORE .)


state 109

    (65) compop -> LESS .

    empty           reduce using rule 65 (compop -> LESS .)


state 110

    (69) compop -> L_EQ .

    empty           reduce using rule 69 (compop -> L_EQ .)


state 111

    (61) if_stmt -> IF L_PAR cond R_PAR . decl stmt_list else_part ENDIF
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id EQ_EQ str SEMI
    (9) var_decl -> . var_type id_list SEMI
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 8
    STRING          shift and go to state 9
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 7
    decl                           shift and go to state 121
    string_decl                    shift and go to state 11
    var_decl                       shift and go to state 12

state 112

    (38) write_stmt -> WRITE L_PAR id_list R_PAR . SEMI

    SEMI            shift and go to state 122


state 113

    (48) call_expr -> id L_PAR . expr_list R_PAR
    (49) expr_list -> . expr expr_list_tail
    (50) expr_list -> . empty
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 123

    expr_list                      shift and go to state 124
    expr                           shift and go to state 125
    expr_prefix                    shift and go to state 75

state 114

    (59) mulop -> MULT .

    L_PAR           reduce using rule 59 (mulop -> MULT .)
    INTLITERAL      reduce using rule 59 (mulop -> MULT .)
    FLOATLITERAL    reduce using rule 59 (mulop -> MULT .)
    IDENTIFIER      reduce using rule 59 (mulop -> MULT .)


state 115

    (44) factor_prefix -> factor_prefix postfix_expr mulop .

    L_PAR           reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)
    INTLITERAL      reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)
    FLOATLITERAL    reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)
    IDENTIFIER      reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)


state 116

    (60) mulop -> DIV .

    L_PAR           reduce using rule 60 (mulop -> DIV .)
    INTLITERAL      reduce using rule 60 (mulop -> DIV .)
    FLOATLITERAL    reduce using rule 60 (mulop -> DIV .)
    IDENTIFIER      reduce using rule 60 (mulop -> DIV .)


state 117

    (53) primary -> L_PAR expr . R_PAR

    R_PAR           shift and go to state 126


state 118

    (37) read_stmt -> READ L_PAR id_list R_PAR SEMI .

    empty           reduce using rule 37 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    IF              reduce using rule 37 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    WHILE           reduce using rule 37 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    READ            reduce using rule 37 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    WRITE           reduce using rule 37 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    RETURN          reduce using rule 37 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)
    IDENTIFIER      reduce using rule 37 (read_stmt -> READ L_PAR id_list R_PAR SEMI .)


state 119

    (71) while_stmt -> WHILE L_PAR cond R_PAR decl . stmt_list ENDWHILE
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMI
    (37) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (38) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (39) return_stmt -> . RETURN expr
    (36) assign_expr -> . id EQ_EQ expr
    (2) id -> . IDENTIFIER

    empty           shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 66
    READ            shift and go to state 60
    WRITE           shift and go to state 70
    RETURN          shift and go to state 58
    IDENTIFIER      shift and go to state 4

    while_stmt                     shift and go to state 56
    return_stmt                    shift and go to state 57
    assign_stmt                    shift and go to state 59
    write_stmt                     shift and go to state 67
    assign_expr                    shift and go to state 69
    id                             shift and go to state 62
    stmt                           shift and go to state 65
    base_stmt                      shift and go to state 63
    read_stmt                      shift and go to state 64
    if_stmt                        shift and go to state 71
    stmt_list                      shift and go to state 127

state 120

    (64) cond -> expr compop expr .

    R_PAR           reduce using rule 64 (cond -> expr compop expr .)


state 121

    (61) if_stmt -> IF L_PAR cond R_PAR decl . stmt_list else_part ENDIF
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMI
    (37) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (38) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (39) return_stmt -> . RETURN expr
    (36) assign_expr -> . id EQ_EQ expr
    (2) id -> . IDENTIFIER

    empty           shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 66
    READ            shift and go to state 60
    WRITE           shift and go to state 70
    RETURN          shift and go to state 58
    IDENTIFIER      shift and go to state 4

    while_stmt                     shift and go to state 56
    return_stmt                    shift and go to state 57
    assign_stmt                    shift and go to state 59
    write_stmt                     shift and go to state 67
    assign_expr                    shift and go to state 69
    id                             shift and go to state 62
    stmt                           shift and go to state 65
    base_stmt                      shift and go to state 63
    read_stmt                      shift and go to state 64
    if_stmt                        shift and go to state 71
    stmt_list                      shift and go to state 128

state 122

    (38) write_stmt -> WRITE L_PAR id_list R_PAR SEMI .

    empty           reduce using rule 38 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    IF              reduce using rule 38 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    WHILE           reduce using rule 38 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    READ            reduce using rule 38 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    WRITE           reduce using rule 38 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    RETURN          reduce using rule 38 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)
    IDENTIFIER      reduce using rule 38 (write_stmt -> WRITE L_PAR id_list R_PAR SEMI .)


state 123

    (50) expr_list -> empty .
    (42) expr_prefix -> empty .

    R_PAR           reduce using rule 50 (expr_list -> empty .)
    empty           reduce using rule 42 (expr_prefix -> empty .)


state 124

    (48) call_expr -> id L_PAR expr_list . R_PAR

    R_PAR           shift and go to state 129


state 125

    (49) expr_list -> expr . expr_list_tail
    (51) expr_list_tail -> . COMM expr expr_list_tail
    (52) expr_list_tail -> . empty

    COMM            shift and go to state 131
    empty           shift and go to state 130

    expr_list_tail                 shift and go to state 132

state 126

    (53) primary -> L_PAR expr R_PAR .

    MULT            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    DIV             reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    PLUS            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    MINUS           reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    empty           reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    IF              reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    WHILE           reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    READ            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    WRITE           reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    RETURN          reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    IDENTIFIER      reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    SEMI            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    LESS            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    MORE            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    EQ              reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    N_EQ            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    L_EQ            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    R_EQ            reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    R_PAR           reduce using rule 53 (primary -> L_PAR expr R_PAR .)
    COMM            reduce using rule 53 (primary -> L_PAR expr R_PAR .)


state 127

    (71) while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list . ENDWHILE

    ENDWHILE        shift and go to state 133


state 128

    (61) if_stmt -> IF L_PAR cond R_PAR decl stmt_list . else_part ENDIF
    (62) else_part -> . ELSE decl stmt_list
    (63) else_part -> . empty

    ELSE            shift and go to state 136
    empty           shift and go to state 134

    else_part                      shift and go to state 135

state 129

    (48) call_expr -> id L_PAR expr_list R_PAR .

    MULT            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    DIV             reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    PLUS            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    MINUS           reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    empty           reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    IF              reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    WHILE           reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    READ            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    WRITE           reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    RETURN          reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    IDENTIFIER      reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    SEMI            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    LESS            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    MORE            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    EQ              reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    N_EQ            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    L_EQ            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    R_EQ            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    R_PAR           reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)
    COMM            reduce using rule 48 (call_expr -> id L_PAR expr_list R_PAR .)


state 130

    (52) expr_list_tail -> empty .

    R_PAR           reduce using rule 52 (expr_list_tail -> empty .)


state 131

    (51) expr_list_tail -> COMM . expr expr_list_tail
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    empty           shift and go to state 73

    expr                           shift and go to state 137
    expr_prefix                    shift and go to state 75

state 132

    (49) expr_list -> expr expr_list_tail .

    R_PAR           reduce using rule 49 (expr_list -> expr expr_list_tail .)


state 133

    (71) while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .

    empty           reduce using rule 71 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    IF              reduce using rule 71 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    WHILE           reduce using rule 71 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    READ            reduce using rule 71 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    WRITE           reduce using rule 71 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    RETURN          reduce using rule 71 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)
    IDENTIFIER      reduce using rule 71 (while_stmt -> WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE .)


state 134

    (63) else_part -> empty .

    ENDIF           reduce using rule 63 (else_part -> empty .)


state 135

    (61) if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part . ENDIF

    ENDIF           shift and go to state 138


state 136

    (62) else_part -> ELSE . decl stmt_list
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id EQ_EQ str SEMI
    (9) var_decl -> . var_type id_list SEMI
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    empty           shift and go to state 8
    STRING          shift and go to state 9
    FLOAT           shift and go to state 14
    INT             shift and go to state 6

    var_type                       shift and go to state 7
    decl                           shift and go to state 139
    string_decl                    shift and go to state 11
    var_decl                       shift and go to state 12

state 137

    (51) expr_list_tail -> COMM expr . expr_list_tail
    (51) expr_list_tail -> . COMM expr expr_list_tail
    (52) expr_list_tail -> . empty

    COMM            shift and go to state 131
    empty           shift and go to state 130

    expr_list_tail                 shift and go to state 140

state 138

    (61) if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .

    empty           reduce using rule 61 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    IF              reduce using rule 61 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    WHILE           reduce using rule 61 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    READ            reduce using rule 61 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    WRITE           reduce using rule 61 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    RETURN          reduce using rule 61 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)
    IDENTIFIER      reduce using rule 61 (if_stmt -> IF L_PAR cond R_PAR decl stmt_list else_part ENDIF .)


state 139

    (62) else_part -> ELSE decl . stmt_list
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF L_PAR cond R_PAR decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE L_PAR cond R_PAR decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMI
    (37) read_stmt -> . READ L_PAR id_list R_PAR SEMI
    (38) write_stmt -> . WRITE L_PAR id_list R_PAR SEMI
    (39) return_stmt -> . RETURN expr
    (36) assign_expr -> . id EQ_EQ expr
    (2) id -> . IDENTIFIER

    empty           shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 66
    READ            shift and go to state 60
    WRITE           shift and go to state 70
    RETURN          shift and go to state 58
    IDENTIFIER      shift and go to state 4

    while_stmt                     shift and go to state 56
    return_stmt                    shift and go to state 57
    assign_stmt                    shift and go to state 59
    write_stmt                     shift and go to state 67
    id                             shift and go to state 62
    assign_expr                    shift and go to state 69
    base_stmt                      shift and go to state 63
    stmt                           shift and go to state 65
    read_stmt                      shift and go to state 64
    if_stmt                        shift and go to state 71
    stmt_list                      shift and go to state 141

state 140

    (51) expr_list_tail -> COMM expr expr_list_tail .

    R_PAR           reduce using rule 51 (expr_list_tail -> COMM expr expr_list_tail .)


state 141

    (62) else_part -> ELSE decl stmt_list .

    ENDIF           reduce using rule 62 (else_part -> ELSE decl stmt_list .)

